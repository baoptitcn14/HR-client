//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_SYS_URL = new InjectionToken<string>('API_SYS_URL');

@Injectable()
export class ApisServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    listEndpoints(): Observable<ApiDto[]> {
        let url_ = this.baseUrl + "/api/services/sys/Apis/ListEndpoints";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListEndpoints(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListEndpoints(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiDto[]>;
        }));
    }

    protected processListEndpoints(response: HttpResponseBase): Observable<ApiDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200.result)) {
                result200 = [] as any;
                for (let item of resultData200.result)
                    result200!.push(ApiDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CacheServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    clear(body: CacheDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/Cache/Clear";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClear(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClear(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CategoryInputDto | undefined): Observable<CategoryOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Category/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CategoryOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CategoryInputDto | undefined): Observable<CategoryOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Category/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CategoryOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: ViewDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/Category/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getList(body: CategoryQueryDto | undefined): Observable<CategoryOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sys/Category/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<CategoryOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200.result)) {
                result200 = [] as any;
                for (let item of resultData200.result)
                    result200!.push(CategoryOutputDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: CategoryQueryDto | undefined): Observable<CategoryOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/Category/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CategoryOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CategoryInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getList(body: CategoryQueryDto | undefined): Observable<CategoryOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sys/CategoryInfo/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<CategoryOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200.result)) {
                result200 = [] as any;
                for (let item of resultData200.result)
                    result200!.push(CategoryOutputDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CmsPageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CmsPageInputDto | undefined): Observable<CmsPageOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/CmsPage/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CmsPageOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CmsPageOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CmsPageOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CmsPageOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CmsPageInputDto | undefined): Observable<CmsPageOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/CmsPage/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CmsPageOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CmsPageOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CmsPageOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CmsPageOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: CmsPageInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/CmsPage/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    get(body: ViewDto | undefined): Observable<CmsPageOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/CmsPage/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CmsPageOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CmsPageOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CmsPageOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CmsPageOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: CmsPageQueryDto | undefined): Observable<CmsPageOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/CmsPage/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CmsPageOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CmsPageOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CmsPageOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CmsPageOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CurrentUserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CurrentUserInputDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/sys/CurrentUser/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    changePassword(body: ChangePasswordDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/CurrentUser/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    setDefaultTenant(body: SetDefaultTenantDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/CurrentUser/SetDefaultTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetDefaultTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    logout(body: LogoutDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/CurrentUser/Logout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getUser(body: ViewDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/sys/CurrentUser/GetUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processGetUser(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getTenant(body: ViewDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/sys/CurrentUser/GetTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processGetTenant(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getTenants(body: ViewDto | undefined): Observable<TenantDto[]> {
        let url_ = this.baseUrl + "/api/services/sys/CurrentUser/GetTenants";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto[]>;
        }));
    }

    protected processGetTenants(response: HttpResponseBase): Observable<TenantDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200.result)) {
                result200 = [] as any;
                for (let item of resultData200.result)
                    result200!.push(TenantDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getOrganizations(body: ViewDto | undefined): Observable<UserOrganizationDto[]> {
        let url_ = this.baseUrl + "/api/services/sys/CurrentUser/GetOrganizations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserOrganizationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserOrganizationDto[]>;
        }));
    }

    protected processGetOrganizations(response: HttpResponseBase): Observable<UserOrganizationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200.result)) {
                result200 = [] as any;
                for (let item of resultData200.result)
                    result200!.push(UserOrganizationDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DataServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    setData(body: DataInputDto | undefined): Observable<DataOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Data/SetData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataOutputDto>;
        }));
    }

    protected processSetData(response: HttpResponseBase): Observable<DataOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getData(body: DataInputDto | undefined): Observable<DataOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Data/GetData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataOutputDto>;
        }));
    }

    protected processGetData(response: HttpResponseBase): Observable<DataOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DeviceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    connect(body: ConnectionUserDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/Device/Connect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConnect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConnect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processConnect(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    signOut(body: SignOutDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/Device/SignOut";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignOut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSignOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DeviceSystemServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    signOut(body: SignOutDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/DeviceSystem/SignOut";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignOut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSignOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EntityPermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: EntityPermissionInputDto | undefined): Observable<EntityPermissionOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/EntityPermission/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityPermissionOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityPermissionOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<EntityPermissionOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityPermissionOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: EntityPermissionInputDto | undefined): Observable<EntityPermissionOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/EntityPermission/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityPermissionOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityPermissionOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<EntityPermissionOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityPermissionOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: StringEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/EntityPermission/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createList(body: EntityPermissionInputDto[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/EntityPermission/CreateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteList(body: StringEntityDto[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/EntityPermission/DeleteList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    setList(body: EntityPermissionInputDto[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/EntityPermission/SetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getList(body: EntityPermissionQueryDto | undefined): Observable<EntityPermissionOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sys/EntityPermission/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityPermissionOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityPermissionOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<EntityPermissionOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200.result)) {
                result200 = [] as any;
                for (let item of resultData200.result)
                    result200!.push(EntityPermissionOutputDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EvaluationFormServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: EvaluationFormInputDto | undefined): Observable<EvaluationFormOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/EvaluationForm/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EvaluationFormOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EvaluationFormOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<EvaluationFormOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EvaluationFormOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: EvaluationFormInputDto | undefined): Observable<EvaluationFormOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/EvaluationForm/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EvaluationFormOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EvaluationFormOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<EvaluationFormOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EvaluationFormOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    get(body: ViewDto | undefined): Observable<EvaluationFormOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/EvaluationForm/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EvaluationFormOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EvaluationFormOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<EvaluationFormOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EvaluationFormOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: EvaluationFormQueryDto | undefined): Observable<EvaluationFormOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/EvaluationForm/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EvaluationFormOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EvaluationFormOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<EvaluationFormOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EvaluationFormOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EvaluationFormDetailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    get(body: ViewDto | undefined): Observable<EvaluationFormDetailOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/EvaluationFormDetail/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EvaluationFormDetailOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EvaluationFormDetailOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<EvaluationFormDetailOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EvaluationFormDetailOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: EvaluationFormDetailQueryDto | undefined): Observable<EvaluationFormDetailOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/EvaluationFormDetail/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EvaluationFormDetailOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EvaluationFormDetailOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<EvaluationFormDetailOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EvaluationFormDetailOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ExecServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    exec(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/sys/Exec/Exec";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExec(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExec(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processExec(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ExternalTokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/ExternalTokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class FActionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: FActionInputDto | undefined): Observable<FActionOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/FAction/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FActionOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FActionOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FActionOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FActionOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: FActionInputDto | undefined): Observable<FActionOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/FAction/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FActionOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FActionOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FActionOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FActionOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: StringEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/FAction/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getList(body: FActionQueryDto | undefined): Observable<FActionOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sys/FAction/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FActionOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FActionOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<FActionOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200.result)) {
                result200 = [] as any;
                for (let item of resultData200.result)
                    result200!.push(FActionOutputDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class FeatureServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: FeatureInputDto | undefined): Observable<FeatureOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Feature/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FeatureOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FeatureOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FeatureOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FeatureOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: FeatureInputDto | undefined): Observable<FeatureOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Feature/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FeatureOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FeatureOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FeatureOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FeatureOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: ViewDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/Feature/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getList(body: FeatureQueryDto | undefined): Observable<FeatureOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sys/Feature/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FeatureOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FeatureOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<FeatureOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200.result)) {
                result200 = [] as any;
                for (let item of resultData200.result)
                    result200!.push(FeatureOutputDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class FileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param key (optional) 
     * @param folder (optional) 
     * @return OK
     */
    getFile(key: string | undefined, folder: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/File/GetFile?";
        if (key === null)
            throw new globalThis.Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        if (folder === null)
            throw new globalThis.Error("The parameter 'folder' cannot be null.");
        else if (folder !== undefined)
            url_ += "folder=" + encodeURIComponent("" + folder) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param key (optional) 
     * @param folder (optional) 
     * @return OK
     */
    getLinkFile(key: string | undefined, folder: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/File/GetLinkFile?";
        if (key === null)
            throw new globalThis.Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        if (folder === null)
            throw new globalThis.Error("The parameter 'folder' cannot be null.");
        else if (folder !== undefined)
            url_ += "folder=" + encodeURIComponent("" + folder) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLinkFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinkFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetLinkFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param refId (optional) 
     * @param folder (optional) 
     * @return Created
     */
    uploadFile(refId: string | undefined, folder: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/File/UploadFile?";
        if (refId === null)
            throw new globalThis.Error("The parameter 'refId' cannot be null.");
        else if (refId !== undefined)
            url_ += "refId=" + encodeURIComponent("" + refId) + "&";
        if (folder === null)
            throw new globalThis.Error("The parameter 'folder' cannot be null.");
        else if (folder !== undefined)
            url_ += "folder=" + encodeURIComponent("" + folder) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploadFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 415) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unsupported Media Type", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    buildFileData(body: DataFileDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/sys/File/BuildFileData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuildFileData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuildFileData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processBuildFileData(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class HrCompanyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: HrCompanyInputDto | undefined): Observable<HrCompanyOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/HrCompany/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HrCompanyOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HrCompanyOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<HrCompanyOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HrCompanyOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: HrCompanyInputDto | undefined): Observable<HrCompanyOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/HrCompany/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HrCompanyOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HrCompanyOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<HrCompanyOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HrCompanyOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: ViewDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/HrCompany/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    get(body: ViewDto | undefined): Observable<HrCompanyOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/HrCompany/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HrCompanyOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HrCompanyOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<HrCompanyOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HrCompanyOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: HrCompanyQueryDto | undefined): Observable<HrCompanyOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/HrCompany/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HrCompanyOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HrCompanyOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<HrCompanyOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HrCompanyOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getByTenantId(body: ViewDto | undefined): Observable<HrCompanyOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/HrCompany/GetByTenantId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByTenantId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HrCompanyOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HrCompanyOutputDto>;
        }));
    }

    protected processGetByTenantId(response: HttpResponseBase): Observable<HrCompanyOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HrCompanyOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class HrCompanyInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    get(body: HrCompanyQueryDto | undefined): Observable<HrCompanyOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/HrCompanyInfo/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HrCompanyOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HrCompanyOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<HrCompanyOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HrCompanyOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param tenantId (optional) 
     * @return OK
     */
    getByTenantId(tenantId: number | undefined): Observable<HrCompanyOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/HrCompanyInfo/GetByTenantId?";
        if (tenantId === null)
            throw new globalThis.Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByTenantId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HrCompanyOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HrCompanyOutputDto>;
        }));
    }

    protected processGetByTenantId(response: HttpResponseBase): Observable<HrCompanyOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HrCompanyOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: HrCompanyQueryDto | undefined): Observable<HrCompanyOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/HrCompanyInfo/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HrCompanyOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HrCompanyOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<HrCompanyOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HrCompanyOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class IdsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getId(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/sys/Ids/GetId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetId(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class InterestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: InterestInputDto | undefined): Observable<InterestOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Interest/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InterestOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InterestOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<InterestOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InterestOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: InterestInputDto | undefined): Observable<InterestOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Interest/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InterestOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InterestOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<InterestOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InterestOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: ViewDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/Interest/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    get(body: ViewDto | undefined): Observable<InterestOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Interest/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InterestOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InterestOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<InterestOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InterestOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: InterestQueryDto | undefined): Observable<InterestOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/Interest/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InterestOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InterestOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<InterestOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InterestOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class InterviewScheduleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: InterviewScheduleInputDto | undefined): Observable<InterviewScheduleOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/InterviewSchedule/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InterviewScheduleOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InterviewScheduleOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<InterviewScheduleOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InterviewScheduleOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: InterviewScheduleInputDto | undefined): Observable<InterviewScheduleOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/InterviewSchedule/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InterviewScheduleOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InterviewScheduleOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<InterviewScheduleOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InterviewScheduleOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: ViewDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/InterviewSchedule/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    get(body: ViewDto | undefined): Observable<InterviewScheduleOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/InterviewSchedule/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InterviewScheduleOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InterviewScheduleOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<InterviewScheduleOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InterviewScheduleOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: InterviewScheduleQueryDto | undefined): Observable<InterviewScheduleOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/InterviewSchedule/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InterviewScheduleOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InterviewScheduleOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<InterviewScheduleOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InterviewScheduleOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class JobApplicationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: JobApplicationInputDto | undefined): Observable<JobApplicationOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/JobApplication/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobApplicationOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobApplicationOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<JobApplicationOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobApplicationOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: JobApplicationInputDto | undefined): Observable<JobApplicationOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/JobApplication/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobApplicationOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobApplicationOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<JobApplicationOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobApplicationOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    get(body: ViewDto | undefined): Observable<JobApplicationOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/JobApplication/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobApplicationOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobApplicationOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<JobApplicationOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobApplicationOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: JobApplicationQueryDto | undefined): Observable<JobApplicationOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/JobApplication/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobApplicationOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobApplicationOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<JobApplicationOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobApplicationOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class JobApplicationFieldServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    get(body: ViewDto | undefined): Observable<JobApplicationFieldOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/JobApplicationField/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobApplicationFieldOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobApplicationFieldOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<JobApplicationFieldOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobApplicationFieldOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: JobApplicationFieldQueryDto | undefined): Observable<JobApplicationFieldOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/JobApplicationField/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobApplicationFieldOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobApplicationFieldOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<JobApplicationFieldOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobApplicationFieldOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class JobApplicationInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    get(body: JobApplicationQueryDto | undefined): Observable<JobApplicationOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/JobApplicationInfo/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobApplicationOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobApplicationOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<JobApplicationOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobApplicationOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: JobApplicationQueryDto | undefined): Observable<JobApplicationOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/JobApplicationInfo/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobApplicationOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobApplicationOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<JobApplicationOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobApplicationOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class JobFieldServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: JobFieldInputDto | undefined): Observable<JobFieldOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/JobField/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobFieldOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobFieldOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<JobFieldOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobFieldOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: JobFieldInputDto | undefined): Observable<JobFieldOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/JobField/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobFieldOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobFieldOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<JobFieldOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobFieldOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: ViewDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/JobField/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createOrUpdateList(body: JobFieldInputDto[] | undefined): Observable<JobFieldOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sys/JobField/CreateOrUpdateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobFieldOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobFieldOutputDto[]>;
        }));
    }

    protected processCreateOrUpdateList(response: HttpResponseBase): Observable<JobFieldOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200.result)) {
                result200 = [] as any;
                for (let item of resultData200.result)
                    result200!.push(JobFieldOutputDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    get(body: ViewDto | undefined): Observable<JobFieldOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/JobField/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobFieldOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobFieldOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<JobFieldOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobFieldOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: JobFieldQueryDto | undefined): Observable<JobFieldOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/JobField/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobFieldOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobFieldOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<JobFieldOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobFieldOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class JobFieldInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    get(body: JobFieldQueryDto | undefined): Observable<JobFieldOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/JobFieldInfo/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobFieldOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobFieldOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<JobFieldOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobFieldOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: JobFieldQueryDto | undefined): Observable<JobFieldOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/JobFieldInfo/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobFieldOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobFieldOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<JobFieldOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobFieldOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class JobPostServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: JobPostInputDto | undefined): Observable<JobPostOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/JobPost/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobPostOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobPostOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<JobPostOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobPostOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: JobPostInputDto | undefined): Observable<JobPostOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/JobPost/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobPostOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobPostOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<JobPostOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobPostOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: ViewDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/JobPost/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    get(body: ViewDto | undefined): Observable<JobPostOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/JobPost/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobPostOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobPostOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<JobPostOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobPostOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: JobPostQueryDto | undefined): Observable<JobPostOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/JobPost/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobPostOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobPostOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<JobPostOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobPostOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class JobPostFieldServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: JobPostFieldInputDto | undefined): Observable<JobPostFieldOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/JobPostField/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobPostFieldOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobPostFieldOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<JobPostFieldOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobPostFieldOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: JobPostFieldInputDto | undefined): Observable<JobPostFieldOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/JobPostField/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobPostFieldOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobPostFieldOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<JobPostFieldOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobPostFieldOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: ViewDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/JobPostField/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    get(body: ViewDto | undefined): Observable<JobPostFieldOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/JobPostField/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobPostFieldOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobPostFieldOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<JobPostFieldOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobPostFieldOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: JobPostFieldQueryDto | undefined): Observable<JobPostFieldOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/JobPostField/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobPostFieldOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobPostFieldOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<JobPostFieldOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobPostFieldOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class JobPostFieldInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getList(body: JobPostFieldQueryDto | undefined): Observable<JobPostFieldOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sys/JobPostFieldInfo/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobPostFieldOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobPostFieldOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<JobPostFieldOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200.result)) {
                result200 = [] as any;
                for (let item of resultData200.result)
                    result200!.push(JobPostFieldOutputDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class JobPostInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    get(body: ViewDto | undefined): Observable<JobPostOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/JobPostInfo/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobPostOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobPostOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<JobPostOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobPostOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: JobPostQueryDto | undefined): Observable<JobPostOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/JobPostInfo/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobPostOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobPostOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<JobPostOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobPostOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LibServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getNewId(body: NewIdDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/sys/Lib/GetNewId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetNewId(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MenuServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: MenuInputDto | undefined): Observable<MenuOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Menu/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MenuOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MenuOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<MenuOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MenuOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: MenuInputDto | undefined): Observable<MenuOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Menu/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MenuOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MenuOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<MenuOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MenuOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: ViewDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/Menu/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getList(body: MenuQueryDto | undefined): Observable<MenuOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sys/Menu/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MenuOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MenuOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<MenuOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200.result)) {
                result200 = [] as any;
                for (let item of resultData200.result)
                    result200!.push(MenuOutputDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MenuInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getList(body: MenuQueryDto | undefined): Observable<MenuInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/sys/MenuInfo/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MenuInfoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MenuInfoDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<MenuInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200.result)) {
                result200 = [] as any;
                for (let item of resultData200.result)
                    result200!.push(MenuInfoDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    checkPermission(body: CheckMenuPermissionDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/sys/MenuInfo/CheckPermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckPermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckPermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckPermission(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MenuSystemServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    defaultTenantCreate(body: DefaultTenantSysInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/MenuSystem/DefaultTenantCreate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDefaultTenantCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDefaultTenantCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDefaultTenantCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MessageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: MessageInputDto | undefined): Observable<MessageOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Message/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MessageOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MessageOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<MessageOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: MessageInputDto | undefined): Observable<MessageOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Message/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MessageOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MessageOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<MessageOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: StringEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/Message/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getList(body: MessageQueryDto | undefined): Observable<MessageOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sys/Message/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MessageOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MessageOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<MessageOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200.result)) {
                result200 = [] as any;
                for (let item of resultData200.result)
                    result200!.push(MessageOutputDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: MessageQueryDto | undefined): Observable<MessageOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/Message/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MessageOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MessageOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<MessageOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MgServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteData(body: DocumentInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/Mg/DeleteData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class NotifyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    sendMessages(body: SendMessagesDto | undefined): Observable<SendMessageResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/Notify/SendMessages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMessages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SendMessageResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SendMessageResultDto>;
        }));
    }

    protected processSendMessages(response: HttpResponseBase): Observable<SendMessageResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SendMessageResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OrganizationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: OrganizationInputDto | undefined): Observable<OrganizationOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Organization/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<OrganizationOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: OrganizationInputDto | undefined): Observable<OrganizationOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Organization/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<OrganizationOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: ViewDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/Organization/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getList(body: OrganizationQueryDto | undefined): Observable<OrganizationOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sys/Organization/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<OrganizationOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200.result)) {
                result200 = [] as any;
                for (let item of resultData200.result)
                    result200!.push(OrganizationOutputDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OrganizationTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: OrganizationTypeInputDto | undefined): Observable<OrganizationTypeOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/OrganizationType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationTypeOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationTypeOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<OrganizationTypeOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationTypeOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: OrganizationTypeInputDto | undefined): Observable<OrganizationTypeOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/OrganizationType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationTypeOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationTypeOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<OrganizationTypeOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationTypeOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: ViewDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/OrganizationType/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getList(body: OrganizationTypeQueryDto | undefined): Observable<OrganizationTypeOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sys/OrganizationType/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationTypeOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationTypeOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<OrganizationTypeOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200.result)) {
                result200 = [] as any;
                for (let item of resultData200.result)
                    result200!.push(OrganizationTypeOutputDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PdfFileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param key (optional) 
     * @param folder (optional) 
     * @param from (optional) 
     * @param to (optional) 
     * @return OK
     */
    getPages(key: string | undefined, folder: string | undefined, from: number | undefined, to: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/PdfFile/GetPages?";
        if (key === null)
            throw new globalThis.Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        if (folder === null)
            throw new globalThis.Error("The parameter 'folder' cannot be null.");
        else if (folder !== undefined)
            url_ += "folder=" + encodeURIComponent("" + folder) + "&";
        if (from === null)
            throw new globalThis.Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (to === null)
            throw new globalThis.Error("The parameter 'to' cannot be null.");
        else if (to !== undefined)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetPages(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param key (optional) 
     * @param folder (optional) 
     * @param index (optional) 
     * @return OK
     */
    getImage(key: string | undefined, folder: string | undefined, index: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/PdfFile/GetImage?";
        if (key === null)
            throw new globalThis.Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        if (folder === null)
            throw new globalThis.Error("The parameter 'folder' cannot be null.");
        else if (folder !== undefined)
            url_ += "folder=" + encodeURIComponent("" + folder) + "&";
        if (index === null)
            throw new globalThis.Error("The parameter 'index' cannot be null.");
        else if (index !== undefined)
            url_ += "index=" + encodeURIComponent("" + index) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetImage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: PermissionInputDto | undefined): Observable<PermissionOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Permission/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PermissionOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: PermissionInputDto | undefined): Observable<PermissionOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Permission/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PermissionOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: ViewDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/Permission/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getList(body: PermissionQueryDto | undefined): Observable<PermissionOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sys/Permission/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<PermissionOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200.result)) {
                result200 = [] as any;
                for (let item of resultData200.result)
                    result200!.push(PermissionOutputDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PostServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: PostInputDto | undefined): Observable<PostOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Post/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PostOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: PostInputDto | undefined): Observable<PostOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Post/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PostOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: PostInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/Post/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    get(body: ViewDto | undefined): Observable<PostOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Post/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PostOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: PostQueryDto | undefined): Observable<PostOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/Post/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PostOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAllExt(body: PostQueryDto | undefined): Observable<PostOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/Post/GetAllExt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllExt(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllExt(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAllExt(response: HttpResponseBase): Observable<PostOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PostInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    get(body: PostQueryDto | undefined): Observable<PostOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/PostInfo/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PostOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getByCode(body: PostQueryDto | undefined): Observable<PostOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/PostInfo/GetByCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostOutputDto>;
        }));
    }

    protected processGetByCode(response: HttpResponseBase): Observable<PostOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: PostQueryDto | undefined): Observable<PostOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/PostInfo/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PostOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAllExt(body: PostQueryDto | undefined): Observable<PostOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/PostInfo/GetAllExt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllExt(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllExt(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAllExt(response: HttpResponseBase): Observable<PostOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RegistrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    registerOrganizationUser(body: RegisterOrganizationUserDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/sys/Registration/RegisterOrganizationUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterOrganizationUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterOrganizationUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processRegisterOrganizationUser(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    approveRegisterOrganizationUser(body: StringEntityDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/sys/Registration/ApproveRegisterOrganizationUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveRegisterOrganizationUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveRegisterOrganizationUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processApproveRegisterOrganizationUser(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: RegisterInputDto | undefined): Observable<RegisterOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Registration/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RegisterOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: RegisterInputDto | undefined): Observable<RegisterOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Registration/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RegisterOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: StringEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/Registration/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RegistrationInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    registerTenant(body: RegisterTenantDto | undefined): Observable<RegisterUserResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/RegistrationInfo/RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterUserResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterUserResultDto>;
        }));
    }

    protected processRegisterTenant(response: HttpResponseBase): Observable<RegisterUserResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterUserResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    registerUser(body: RegisterUserDto | undefined): Observable<RegisterUserResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/RegistrationInfo/RegisterUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterUserResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterUserResultDto>;
        }));
    }

    protected processRegisterUser(response: HttpResponseBase): Observable<RegisterUserResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterUserResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    requestEmailConfirm(body: RequestEmailConfirmDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/sys/RegistrationInfo/RequestEmailConfirm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestEmailConfirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestEmailConfirm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processRequestEmailConfirm(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: RoleInputDto | undefined): Observable<RoleOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: RoleInputDto | undefined): Observable<RoleOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: ViewDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/Role/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getList(body: RoleQueryDto | undefined): Observable<RoleOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sys/Role/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<RoleOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200.result)) {
                result200 = [] as any;
                for (let item of resultData200.result)
                    result200!.push(RoleOutputDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ScheduleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: ScheduleInputDto | undefined): Observable<ScheduleOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Schedule/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScheduleOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScheduleOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ScheduleOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScheduleOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: ScheduleInputDto | undefined): Observable<ScheduleOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Schedule/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScheduleOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScheduleOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ScheduleOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScheduleOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: StringEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/Schedule/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getList(body: ScheduleQueryDto | undefined): Observable<ScheduleOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sys/Schedule/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScheduleOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScheduleOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<ScheduleOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200.result)) {
                result200 = [] as any;
                for (let item of resultData200.result)
                    result200!.push(ScheduleOutputDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: ScheduleQueryDto | undefined): Observable<ScheduleOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/Schedule/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScheduleOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScheduleOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ScheduleOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScheduleOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SelectionCandidateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    get(body: ViewDto | undefined): Observable<SelectionCandidateOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/SelectionCandidate/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectionCandidateOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectionCandidateOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SelectionCandidateOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectionCandidateOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: SelectionCandidateQueryDto | undefined): Observable<SelectionCandidateOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/SelectionCandidate/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectionCandidateOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectionCandidateOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SelectionCandidateOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectionCandidateOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SelectionFieldServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    get(body: ViewDto | undefined): Observable<SelectionFieldOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/SelectionField/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectionFieldOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectionFieldOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SelectionFieldOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectionFieldOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: SelectionFieldQueryDto | undefined): Observable<SelectionFieldOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/SelectionField/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectionFieldOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectionFieldOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SelectionFieldOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectionFieldOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SelectionJudgeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    get(body: ViewDto | undefined): Observable<SelectionJudgeOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/SelectionJudge/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectionJudgeOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectionJudgeOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SelectionJudgeOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectionJudgeOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: SelectionJudgeQueryDto | undefined): Observable<SelectionJudgeOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/SelectionJudge/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectionJudgeOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectionJudgeOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SelectionJudgeOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectionJudgeOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SelectionRoundServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: SelectionRoundInputDto | undefined): Observable<SelectionRoundOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/SelectionRound/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectionRoundOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectionRoundOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SelectionRoundOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectionRoundOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: SelectionRoundInputDto | undefined): Observable<SelectionRoundOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/SelectionRound/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectionRoundOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectionRoundOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SelectionRoundOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectionRoundOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: ViewDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/SelectionRound/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    get(body: ViewDto | undefined): Observable<SelectionRoundOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/SelectionRound/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectionRoundOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectionRoundOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SelectionRoundOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectionRoundOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: SelectionRoundQueryDto | undefined): Observable<SelectionRoundOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/SelectionRound/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectionRoundOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectionRoundOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SelectionRoundOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectionRoundOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SettingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: SettingInputDto | undefined): Observable<SettingOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Setting/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SettingOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SettingOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    set(body: SettingInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/Setting/Set";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSet(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: SettingInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/Setting/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getList(body: SettingEntityQueryDto | undefined): Observable<SettingOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sys/Setting/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<SettingOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200.result)) {
                result200 = [] as any;
                for (let item of resultData200.result)
                    result200!.push(SettingOutputDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    get(body: ViewDto | undefined): Observable<SettingOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Setting/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SettingOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SettingOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SettingInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getSetting(body: GetSettingDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/sys/SettingInfo/GetSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetSetting(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getSettings(body: GetSettingDto | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/sys/SettingInfo/GetSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetSettings(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200.result)) {
                result200 = [] as any;
                for (let item of resultData200.result)
                    result200!.push(item);
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SettingSystemServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    defaultTenantCreate(body: TenantSettingInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/SettingSystem/DefaultTenantCreate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDefaultTenantCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDefaultTenantCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDefaultTenantCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SSOServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getSSOUser(body: GetSSOUserDto | undefined): Observable<SSOUserDto> {
        let url_ = this.baseUrl + "/api/services/sys/SSO/GetSSOUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSSOUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSSOUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SSOUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SSOUserDto>;
        }));
    }

    protected processGetSSOUser(response: HttpResponseBase): Observable<SSOUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SSOUserDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    checkPermission(body: CheckPermissionDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/sys/SSO/CheckPermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckPermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckPermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckPermission(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getSSOData(body: QueryKeyValueDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/sys/SSO/GetSSOData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSSOData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSSOData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetSSOData(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: TenantInputDto | undefined): Observable<TenantOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: TenantDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/sys/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getList(body: ViewDto | undefined): Observable<TenantDto[]> {
        let url_ = this.baseUrl + "/api/services/sys/Tenant/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<TenantDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200.result)) {
                result200 = [] as any;
                for (let item of resultData200.result)
                    result200!.push(TenantDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantClientServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add(body: TenantInputDto | undefined): Observable<TenantOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/TenantClient/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantOutputDto>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<TenantOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: TenantDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/sys/TenantClient/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    joinTenant(body: TenantModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/JoinTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processJoinTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processJoinTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processJoinTenant(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getOTP(body: OTPModel | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetOTP";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOTP(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOTP(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetOTP(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getEncryptAccessToken(): Observable<string> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetEncryptAccessToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEncryptAccessToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEncryptAccessToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetEncryptAccessToken(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getConfig(): Observable<string> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetConfig";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfig(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetConfig(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: RegisterUserDto | undefined): Observable<UserOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: UserInputDto | undefined): Observable<UserOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: ViewDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/User/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    setPassword(body: ChangePasswordDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/User/SetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    setDefaultTenant(body: SetDefaultTenantDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/User/SetDefaultTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetDefaultTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    setOrganization(body: SetUserOrganizationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/User/SetOrganization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetOrganization(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetOrganization(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createList(body: SetUsersInputDto | undefined): Observable<UserOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sys/User/CreateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserOutputDto[]>;
        }));
    }

    protected processCreateList(response: HttpResponseBase): Observable<UserOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200.result)) {
                result200 = [] as any;
                for (let item of resultData200.result)
                    result200!.push(UserOutputDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    setStatusList(body: SetStatusUsersInputDto | undefined): Observable<StringEntityDto[]> {
        let url_ = this.baseUrl + "/api/services/sys/User/SetStatusList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetStatusList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetStatusList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringEntityDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringEntityDto[]>;
        }));
    }

    protected processSetStatusList(response: HttpResponseBase): Observable<StringEntityDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200.result)) {
                result200 = [] as any;
                for (let item of resultData200.result)
                    result200!.push(StringEntityDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getList(body: UserQueryDto | undefined): Observable<UserOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sys/User/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserOutputDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<UserOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200.result)) {
                result200 = [] as any;
                for (let item of resultData200.result)
                    result200!.push(UserOutputDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: UserQueryDto | undefined): Observable<UserOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/User/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserJobSettingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: UserJobSettingInputDto | undefined): Observable<UserJobSettingOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/UserJobSetting/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserJobSettingOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserJobSettingOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserJobSettingOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserJobSettingOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: UserJobSettingInputDto | undefined): Observable<UserJobSettingOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/UserJobSetting/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserJobSettingOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserJobSettingOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserJobSettingOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserJobSettingOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: ViewDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/UserJobSetting/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    get(body: ViewDto | undefined): Observable<UserJobSettingOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/UserJobSetting/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserJobSettingOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserJobSettingOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserJobSettingOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserJobSettingOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: UserJobSettingQueryDto | undefined): Observable<UserJobSettingOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/UserJobSetting/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserJobSettingOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserJobSettingOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserJobSettingOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserJobSettingOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserJobSettingInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    get(body: UserJobSettingQueryDto | undefined): Observable<UserJobSettingOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/UserJobSettingInfo/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserJobSettingOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserJobSettingOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserJobSettingOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserJobSettingOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: UserJobSettingQueryDto | undefined): Observable<UserJobSettingOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/UserJobSettingInfo/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserJobSettingOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserJobSettingOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserJobSettingOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserJobSettingOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: UserProfileInputDto | undefined): Observable<UserProfileOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/UserProfile/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileOutputDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserProfileOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfileOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: UserProfileInputDto | undefined): Observable<UserProfileOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/UserProfile/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserProfileOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfileOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: ViewDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/UserProfile/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    get(body: ViewDto | undefined): Observable<UserProfileOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/UserProfile/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserProfileOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfileOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: UserProfileQueryDto | undefined): Observable<UserProfileOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/UserProfile/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserProfileOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfileOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserProfileInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    get(body: UserProfileQueryDto | undefined): Observable<UserProfileOutputDto> {
        let url_ = this.baseUrl + "/api/services/sys/UserProfileInfo/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserProfileOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfileOutputDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAll(body: UserProfileQueryDto | undefined): Observable<UserProfileOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sys/UserProfileInfo/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileOutputDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileOutputDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserProfileOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfileOutputDtoPagedResultDto.fromJS(resultData200.result);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ValueServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SYS_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    set(body: ValueDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/Value/Set";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSet(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: StringEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sys/Value/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getValue(body: StringEntityDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/sys/Value/GetValue";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetValue(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetValue(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class ApiDto implements IApiDto {
    area?: string | undefined;
    controller?: string | undefined;
    action?: string | undefined;
    info?: string | undefined;

    constructor(data?: IApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.area = _data["area"];
            this.controller = _data["controller"];
            this.action = _data["action"];
            this.info = _data["info"];
        }
    }

    static fromJS(data: any): ApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["area"] = this.area;
        data["controller"] = this.controller;
        data["action"] = this.action;
        data["info"] = this.info;
        return data;
    }
}

export interface IApiDto {
    area?: string | undefined;
    controller?: string | undefined;
    action?: string | undefined;
    info?: string | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress!: string;
    password!: string;
    rememberClient?: boolean;
    otp?: number;
    tenantName?: string | undefined;
    expriteMinutes?: number;
    defaultTenant?: boolean;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberClient = _data["rememberClient"];
            this.otp = _data["otp"];
            this.tenantName = _data["tenantName"];
            this.expriteMinutes = _data["expriteMinutes"];
            this.defaultTenant = _data["defaultTenant"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        data["otp"] = this.otp;
        data["tenantName"] = this.tenantName;
        data["expriteMinutes"] = this.expriteMinutes;
        data["defaultTenant"] = this.defaultTenant;
        return data;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient?: boolean;
    otp?: number;
    tenantName?: string | undefined;
    expriteMinutes?: number;
    defaultTenant?: boolean;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken?: string | undefined;
    expireInSeconds?: number;
    waitingForActivation?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    creationTime?: string | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.creationTime = _data["creationTime"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["creationTime"] = this.creationTime;
        return data;
    }
}

export interface IAuthenticateResultModel {
    accessToken?: string | undefined;
    expireInSeconds?: number;
    waitingForActivation?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    creationTime?: string | undefined;
}

export class CacheDto implements ICacheDto {
    tenantId?: number | undefined;
    userId?: string | undefined;
    key?: string | undefined;

    constructor(data?: ICacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.key = _data["key"];
        }
    }

    static fromJS(data: any): CacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new CacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["key"] = this.key;
        return data;
    }
}

export interface ICacheDto {
    tenantId?: number | undefined;
    userId?: string | undefined;
    key?: string | undefined;
}

export class CategoryInputDto implements ICategoryInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    hashCode?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;

    constructor(data?: ICategoryInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.parentId = _data["parentId"];
            this.index = _data["index"];
            this.order = _data["order"];
            this.groupCode = _data["groupCode"];
            this.hashCode = _data["hashCode"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
        }
    }

    static fromJS(data: any): CategoryInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["hashCode"] = this.hashCode;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        return data;
    }
}

export interface ICategoryInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    hashCode?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
}

export class CategoryOutputDto implements ICategoryOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    hashCode?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    parentCode?: string | undefined;
    parentName?: string | undefined;

    constructor(data?: ICategoryOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.parentId = _data["parentId"];
            this.index = _data["index"];
            this.order = _data["order"];
            this.groupCode = _data["groupCode"];
            this.hashCode = _data["hashCode"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.parentCode = _data["parentCode"];
            this.parentName = _data["parentName"];
        }
    }

    static fromJS(data: any): CategoryOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["hashCode"] = this.hashCode;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["parentCode"] = this.parentCode;
        data["parentName"] = this.parentName;
        return data;
    }
}

export interface ICategoryOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    hashCode?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    parentCode?: string | undefined;
    parentName?: string | undefined;
}

export class CategoryOutputDtoPagedResultDto implements ICategoryOutputDtoPagedResultDto {
    items?: CategoryOutputDto[] | undefined;
    totalCount?: number;

    constructor(data?: ICategoryOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CategoryOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CategoryOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface ICategoryOutputDtoPagedResultDto {
    items?: CategoryOutputDto[] | undefined;
    totalCount?: number;
}

export class CategoryQueryDto implements ICategoryQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: ICategoryQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): CategoryQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ICategoryQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class ChangePasswordDto implements IChangePasswordDto {
    id?: string | undefined;
    oldPassword?: string | undefined;
    newPassword?: string | undefined;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePasswordDto {
    id?: string | undefined;
    oldPassword?: string | undefined;
    newPassword?: string | undefined;
}

export class CheckMenuPermissionDto implements ICheckMenuPermissionDto {
    id?: string | undefined;
    language?: string | undefined;
    useCache?: boolean;

    constructor(data?: ICheckMenuPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.language = _data["language"];
            this.useCache = _data["useCache"];
        }
    }

    static fromJS(data: any): CheckMenuPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckMenuPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["language"] = this.language;
        data["useCache"] = this.useCache;
        return data;
    }
}

export interface ICheckMenuPermissionDto {
    id?: string | undefined;
    language?: string | undefined;
    useCache?: boolean;
}

export class CheckPermissionDto implements ICheckPermissionDto {
    tenantId?: number | undefined;
    userId?: string | undefined;
    keyDatas?: SSOKeyDataDto[] | undefined;
    useCache?: boolean;

    constructor(data?: ICheckPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["keyDatas"])) {
                this.keyDatas = [] as any;
                for (let item of _data["keyDatas"])
                    this.keyDatas!.push(SSOKeyDataDto.fromJS(item));
            }
            this.useCache = _data["useCache"];
        }
    }

    static fromJS(data: any): CheckPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        if (Array.isArray(this.keyDatas)) {
            data["keyDatas"] = [];
            for (let item of this.keyDatas)
                data["keyDatas"].push(item ? item.toJSON() : undefined as any);
        }
        data["useCache"] = this.useCache;
        return data;
    }
}

export interface ICheckPermissionDto {
    tenantId?: number | undefined;
    userId?: string | undefined;
    keyDatas?: SSOKeyDataDto[] | undefined;
    useCache?: boolean;
}

export class CmsPageInputDto implements ICmsPageInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    slug?: string | undefined;
    fullPath?: string | undefined;
    title?: string | undefined;
    layoutKey?: string | undefined;
    seoJson?: string | undefined;
    propsJson?: string | undefined;
    index?: number;

    constructor(data?: ICmsPageInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this._Name = _data["_Name"];
            this.slug = _data["slug"];
            this.fullPath = _data["fullPath"];
            this.title = _data["title"];
            this.layoutKey = _data["layoutKey"];
            this.seoJson = _data["seoJson"];
            this.propsJson = _data["propsJson"];
            this.index = _data["index"];
        }
    }

    static fromJS(data: any): CmsPageInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CmsPageInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["_Name"] = this._Name;
        data["slug"] = this.slug;
        data["fullPath"] = this.fullPath;
        data["title"] = this.title;
        data["layoutKey"] = this.layoutKey;
        data["seoJson"] = this.seoJson;
        data["propsJson"] = this.propsJson;
        data["index"] = this.index;
        return data;
    }
}

export interface ICmsPageInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    slug?: string | undefined;
    fullPath?: string | undefined;
    title?: string | undefined;
    layoutKey?: string | undefined;
    seoJson?: string | undefined;
    propsJson?: string | undefined;
    index?: number;
}

export class CmsPageOutputDto implements ICmsPageOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    slug?: string | undefined;
    fullPath?: string | undefined;
    title?: string | undefined;
    layoutKey?: string | undefined;
    seoJson?: string | undefined;
    propsJson?: string | undefined;
    index?: number;

    constructor(data?: ICmsPageOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this._Name = _data["_Name"];
            this.slug = _data["slug"];
            this.fullPath = _data["fullPath"];
            this.title = _data["title"];
            this.layoutKey = _data["layoutKey"];
            this.seoJson = _data["seoJson"];
            this.propsJson = _data["propsJson"];
            this.index = _data["index"];
        }
    }

    static fromJS(data: any): CmsPageOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CmsPageOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["_Name"] = this._Name;
        data["slug"] = this.slug;
        data["fullPath"] = this.fullPath;
        data["title"] = this.title;
        data["layoutKey"] = this.layoutKey;
        data["seoJson"] = this.seoJson;
        data["propsJson"] = this.propsJson;
        data["index"] = this.index;
        return data;
    }
}

export interface ICmsPageOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    slug?: string | undefined;
    fullPath?: string | undefined;
    title?: string | undefined;
    layoutKey?: string | undefined;
    seoJson?: string | undefined;
    propsJson?: string | undefined;
    index?: number;
}

export class CmsPageOutputDtoPagedResultDto implements ICmsPageOutputDtoPagedResultDto {
    items?: CmsPageOutputDto[] | undefined;
    totalCount?: number;

    constructor(data?: ICmsPageOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CmsPageOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CmsPageOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CmsPageOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface ICmsPageOutputDtoPagedResultDto {
    items?: CmsPageOutputDto[] | undefined;
    totalCount?: number;
}

export class CmsPageQueryDto implements ICmsPageQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: ICmsPageQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): CmsPageQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CmsPageQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ICmsPageQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class ConnectionUserDto implements IConnectionUserDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    userId?: string | undefined;
    groupId?: string | undefined;
    connectionId?: string | undefined;
    name?: string | undefined;
    userName?: string | undefined;
    emailAddress?: string | undefined;
    clientId?: string | undefined;
    clientType?: string | undefined;
    clientAccessToken?: string | undefined;
    syncTime?: number;

    constructor(data?: IConnectionUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.groupId = _data["groupId"];
            this.connectionId = _data["connectionId"];
            this.name = _data["name"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.clientId = _data["clientId"];
            this.clientType = _data["clientType"];
            this.clientAccessToken = _data["clientAccessToken"];
            this.syncTime = _data["syncTime"];
        }
    }

    static fromJS(data: any): ConnectionUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectionUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["groupId"] = this.groupId;
        data["connectionId"] = this.connectionId;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["clientId"] = this.clientId;
        data["clientType"] = this.clientType;
        data["clientAccessToken"] = this.clientAccessToken;
        data["syncTime"] = this.syncTime;
        return data;
    }
}

export interface IConnectionUserDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    userId?: string | undefined;
    groupId?: string | undefined;
    connectionId?: string | undefined;
    name?: string | undefined;
    userName?: string | undefined;
    emailAddress?: string | undefined;
    clientId?: string | undefined;
    clientType?: string | undefined;
    clientAccessToken?: string | undefined;
    syncTime?: number;
}

export class CurrentUserInputDto implements ICurrentUserInputDto {
    id?: string | undefined;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    fullName?: string | undefined;
    profiles?: string | undefined;
    contacts?: string | undefined;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    dob?: string | undefined;

    constructor(data?: ICurrentUserInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.fullName = _data["fullName"];
            this.profiles = _data["profiles"];
            this.contacts = _data["contacts"];
            this.phoneNumber = _data["phoneNumber"];
            this.gender = _data["gender"];
            this.dob = _data["dob"];
        }
    }

    static fromJS(data: any): CurrentUserInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["fullName"] = this.fullName;
        data["profiles"] = this.profiles;
        data["contacts"] = this.contacts;
        data["phoneNumber"] = this.phoneNumber;
        data["gender"] = this.gender;
        data["dob"] = this.dob;
        return data;
    }
}

export interface ICurrentUserInputDto {
    id?: string | undefined;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    fullName?: string | undefined;
    profiles?: string | undefined;
    contacts?: string | undefined;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    dob?: string | undefined;
}

export class DataFileDto implements IDataFileDto {
    id?: string | undefined;
    value?: string | undefined;
    type?: string | undefined;
    refId?: string | undefined;
    folder?: string | undefined;

    constructor(data?: IDataFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.type = _data["type"];
            this.refId = _data["refId"];
            this.folder = _data["folder"];
        }
    }

    static fromJS(data: any): DataFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["type"] = this.type;
        data["refId"] = this.refId;
        data["folder"] = this.folder;
        return data;
    }
}

export interface IDataFileDto {
    id?: string | undefined;
    value?: string | undefined;
    type?: string | undefined;
    refId?: string | undefined;
    folder?: string | undefined;
}

export class DataInputDto implements IDataInputDto {
    code?: string | undefined;
    value?: string | undefined;
    message?: string | undefined;
    cacheKey?: string | undefined;
    option?: string | undefined;
    useCache?: boolean;

    constructor(data?: IDataInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.value = _data["value"];
            this.message = _data["message"];
            this.cacheKey = _data["cacheKey"];
            this.option = _data["option"];
            this.useCache = _data["useCache"];
        }
    }

    static fromJS(data: any): DataInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["value"] = this.value;
        data["message"] = this.message;
        data["cacheKey"] = this.cacheKey;
        data["option"] = this.option;
        data["useCache"] = this.useCache;
        return data;
    }
}

export interface IDataInputDto {
    code?: string | undefined;
    value?: string | undefined;
    message?: string | undefined;
    cacheKey?: string | undefined;
    option?: string | undefined;
    useCache?: boolean;
}

export class DataOutputDto implements IDataOutputDto {
    code?: string | undefined;
    value?: string | undefined;
    message?: string | undefined;
    cacheKey?: string | undefined;

    constructor(data?: IDataOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.value = _data["value"];
            this.message = _data["message"];
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): DataOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["value"] = this.value;
        data["message"] = this.message;
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IDataOutputDto {
    code?: string | undefined;
    value?: string | undefined;
    message?: string | undefined;
    cacheKey?: string | undefined;
}

export class DefaultTenantSysInputDto implements IDefaultTenantSysInputDto {
    tenantId?: number | undefined;
    userId?: string | undefined;
    key?: string | undefined;
    inputValue?: string | undefined;
    outputValue?: string | undefined;

    constructor(data?: IDefaultTenantSysInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.key = _data["key"];
            this.inputValue = _data["inputValue"];
            this.outputValue = _data["outputValue"];
        }
    }

    static fromJS(data: any): DefaultTenantSysInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new DefaultTenantSysInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["key"] = this.key;
        data["inputValue"] = this.inputValue;
        data["outputValue"] = this.outputValue;
        return data;
    }
}

export interface IDefaultTenantSysInputDto {
    tenantId?: number | undefined;
    userId?: string | undefined;
    key?: string | undefined;
    inputValue?: string | undefined;
    outputValue?: string | undefined;
}

export class DocumentInputDto implements IDocumentInputDto {
    name?: string | undefined;
    key?: string | undefined;
    value?: string | undefined;
    code?: string | undefined;

    constructor(data?: IDocumentInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.key = _data["key"];
            this.value = _data["value"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): DocumentInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["key"] = this.key;
        data["value"] = this.value;
        data["code"] = this.code;
        return data;
    }
}

export interface IDocumentInputDto {
    name?: string | undefined;
    key?: string | undefined;
    value?: string | undefined;
    code?: string | undefined;
}

export class EntityPermissionInputDto implements IEntityPermissionInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    referenceEntityId?: string | undefined;
    organizationTypeId?: string | undefined;
    permissionId?: string | undefined;
    type?: string | undefined;
    action?: string | undefined;

    constructor(data?: IEntityPermissionInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.referenceEntityId = _data["referenceEntityId"];
            this.organizationTypeId = _data["organizationTypeId"];
            this.permissionId = _data["permissionId"];
            this.type = _data["type"];
            this.action = _data["action"];
        }
    }

    static fromJS(data: any): EntityPermissionInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPermissionInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["referenceEntityId"] = this.referenceEntityId;
        data["organizationTypeId"] = this.organizationTypeId;
        data["permissionId"] = this.permissionId;
        data["type"] = this.type;
        data["action"] = this.action;
        return data;
    }
}

export interface IEntityPermissionInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    referenceEntityId?: string | undefined;
    organizationTypeId?: string | undefined;
    permissionId?: string | undefined;
    type?: string | undefined;
    action?: string | undefined;
}

export class EntityPermissionOutputDto implements IEntityPermissionOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    referenceEntityId?: string | undefined;
    organizationTypeId?: string | undefined;
    permissionId?: string | undefined;
    type?: string | undefined;

    constructor(data?: IEntityPermissionOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.referenceEntityId = _data["referenceEntityId"];
            this.organizationTypeId = _data["organizationTypeId"];
            this.permissionId = _data["permissionId"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): EntityPermissionOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPermissionOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["referenceEntityId"] = this.referenceEntityId;
        data["organizationTypeId"] = this.organizationTypeId;
        data["permissionId"] = this.permissionId;
        data["type"] = this.type;
        return data;
    }
}

export interface IEntityPermissionOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    referenceEntityId?: string | undefined;
    organizationTypeId?: string | undefined;
    permissionId?: string | undefined;
    type?: string | undefined;
}

export class EntityPermissionQueryDto implements IEntityPermissionQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: IEntityPermissionQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): EntityPermissionQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPermissionQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IEntityPermissionQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class EvaluationFormDetailInputDto implements IEvaluationFormDetailInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    selectionRoundId?: string | undefined;
    candidateUserId?: string | undefined;
    jobApplicationId?: string | undefined;
    judgeUserId?: string | undefined;
    evaluationFormId?: string | undefined;
    selectionFieldId?: string | undefined;
    comment?: string | undefined;
    value?: string | undefined;

    constructor(data?: IEvaluationFormDetailInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.jobPostId = _data["jobPostId"];
            this.selectionRoundId = _data["selectionRoundId"];
            this.candidateUserId = _data["candidateUserId"];
            this.jobApplicationId = _data["jobApplicationId"];
            this.judgeUserId = _data["judgeUserId"];
            this.evaluationFormId = _data["evaluationFormId"];
            this.selectionFieldId = _data["selectionFieldId"];
            this.comment = _data["comment"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): EvaluationFormDetailInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluationFormDetailInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["jobPostId"] = this.jobPostId;
        data["selectionRoundId"] = this.selectionRoundId;
        data["candidateUserId"] = this.candidateUserId;
        data["jobApplicationId"] = this.jobApplicationId;
        data["judgeUserId"] = this.judgeUserId;
        data["evaluationFormId"] = this.evaluationFormId;
        data["selectionFieldId"] = this.selectionFieldId;
        data["comment"] = this.comment;
        data["value"] = this.value;
        return data;
    }
}

export interface IEvaluationFormDetailInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    selectionRoundId?: string | undefined;
    candidateUserId?: string | undefined;
    jobApplicationId?: string | undefined;
    judgeUserId?: string | undefined;
    evaluationFormId?: string | undefined;
    selectionFieldId?: string | undefined;
    comment?: string | undefined;
    value?: string | undefined;
}

export class EvaluationFormDetailOutputDto implements IEvaluationFormDetailOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    selectionRoundId?: string | undefined;
    candidateUserId?: string | undefined;
    jobApplicationId?: string | undefined;
    judgeUserId?: string | undefined;
    evaluationFormId?: string | undefined;
    selectionFieldId?: string | undefined;
    comment?: string | undefined;
    value?: string | undefined;

    constructor(data?: IEvaluationFormDetailOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.jobPostId = _data["jobPostId"];
            this.selectionRoundId = _data["selectionRoundId"];
            this.candidateUserId = _data["candidateUserId"];
            this.jobApplicationId = _data["jobApplicationId"];
            this.judgeUserId = _data["judgeUserId"];
            this.evaluationFormId = _data["evaluationFormId"];
            this.selectionFieldId = _data["selectionFieldId"];
            this.comment = _data["comment"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): EvaluationFormDetailOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluationFormDetailOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["jobPostId"] = this.jobPostId;
        data["selectionRoundId"] = this.selectionRoundId;
        data["candidateUserId"] = this.candidateUserId;
        data["jobApplicationId"] = this.jobApplicationId;
        data["judgeUserId"] = this.judgeUserId;
        data["evaluationFormId"] = this.evaluationFormId;
        data["selectionFieldId"] = this.selectionFieldId;
        data["comment"] = this.comment;
        data["value"] = this.value;
        return data;
    }
}

export interface IEvaluationFormDetailOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    selectionRoundId?: string | undefined;
    candidateUserId?: string | undefined;
    jobApplicationId?: string | undefined;
    judgeUserId?: string | undefined;
    evaluationFormId?: string | undefined;
    selectionFieldId?: string | undefined;
    comment?: string | undefined;
    value?: string | undefined;
}

export class EvaluationFormDetailOutputDtoPagedResultDto implements IEvaluationFormDetailOutputDtoPagedResultDto {
    items?: EvaluationFormDetailOutputDto[] | undefined;
    totalCount?: number;

    constructor(data?: IEvaluationFormDetailOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EvaluationFormDetailOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EvaluationFormDetailOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluationFormDetailOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IEvaluationFormDetailOutputDtoPagedResultDto {
    items?: EvaluationFormDetailOutputDto[] | undefined;
    totalCount?: number;
}

export class EvaluationFormDetailQueryDto implements IEvaluationFormDetailQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: IEvaluationFormDetailQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): EvaluationFormDetailQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluationFormDetailQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IEvaluationFormDetailQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class EvaluationFormInputDto implements IEvaluationFormInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    jobPostId?: string | undefined;
    selectionRoundId?: string | undefined;
    candidateUserId?: string | undefined;
    jobApplicationId?: string | undefined;
    judgeUserId?: string | undefined;
    comment?: string | undefined;
    evaluation?: string | undefined;
    details?: EvaluationFormDetailInputDto[] | undefined;

    constructor(data?: IEvaluationFormInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this._Name = _data["_Name"];
            this.jobPostId = _data["jobPostId"];
            this.selectionRoundId = _data["selectionRoundId"];
            this.candidateUserId = _data["candidateUserId"];
            this.jobApplicationId = _data["jobApplicationId"];
            this.judgeUserId = _data["judgeUserId"];
            this.comment = _data["comment"];
            this.evaluation = _data["evaluation"];
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details!.push(EvaluationFormDetailInputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EvaluationFormInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluationFormInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["_Name"] = this._Name;
        data["jobPostId"] = this.jobPostId;
        data["selectionRoundId"] = this.selectionRoundId;
        data["candidateUserId"] = this.candidateUserId;
        data["jobApplicationId"] = this.jobApplicationId;
        data["judgeUserId"] = this.judgeUserId;
        data["comment"] = this.comment;
        data["evaluation"] = this.evaluation;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IEvaluationFormInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    jobPostId?: string | undefined;
    selectionRoundId?: string | undefined;
    candidateUserId?: string | undefined;
    jobApplicationId?: string | undefined;
    judgeUserId?: string | undefined;
    comment?: string | undefined;
    evaluation?: string | undefined;
    details?: EvaluationFormDetailInputDto[] | undefined;
}

export class EvaluationFormOutputDto implements IEvaluationFormOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    jobPostId?: string | undefined;
    selectionRoundId?: string | undefined;
    candidateUserId?: string | undefined;
    jobApplicationId?: string | undefined;
    judgeUserId?: string | undefined;
    comment?: string | undefined;
    evaluation?: string | undefined;
    details?: EvaluationFormDetailOutputDto[] | undefined;

    constructor(data?: IEvaluationFormOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this._Name = _data["_Name"];
            this.jobPostId = _data["jobPostId"];
            this.selectionRoundId = _data["selectionRoundId"];
            this.candidateUserId = _data["candidateUserId"];
            this.jobApplicationId = _data["jobApplicationId"];
            this.judgeUserId = _data["judgeUserId"];
            this.comment = _data["comment"];
            this.evaluation = _data["evaluation"];
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details!.push(EvaluationFormDetailOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EvaluationFormOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluationFormOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["_Name"] = this._Name;
        data["jobPostId"] = this.jobPostId;
        data["selectionRoundId"] = this.selectionRoundId;
        data["candidateUserId"] = this.candidateUserId;
        data["jobApplicationId"] = this.jobApplicationId;
        data["judgeUserId"] = this.judgeUserId;
        data["comment"] = this.comment;
        data["evaluation"] = this.evaluation;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IEvaluationFormOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    jobPostId?: string | undefined;
    selectionRoundId?: string | undefined;
    candidateUserId?: string | undefined;
    jobApplicationId?: string | undefined;
    judgeUserId?: string | undefined;
    comment?: string | undefined;
    evaluation?: string | undefined;
    details?: EvaluationFormDetailOutputDto[] | undefined;
}

export class EvaluationFormOutputDtoPagedResultDto implements IEvaluationFormOutputDtoPagedResultDto {
    items?: EvaluationFormOutputDto[] | undefined;
    totalCount?: number;

    constructor(data?: IEvaluationFormOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EvaluationFormOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EvaluationFormOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluationFormOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IEvaluationFormOutputDtoPagedResultDto {
    items?: EvaluationFormOutputDto[] | undefined;
    totalCount?: number;
}

export class EvaluationFormQueryDto implements IEvaluationFormQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: IEvaluationFormQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): EvaluationFormQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluationFormQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IEvaluationFormQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider!: string;
    providerKey!: string;
    providerAccessCode!: string;
    tenantName?: string | undefined;
    defaultTenant?: boolean;
    language?: string | undefined;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
            this.tenantName = _data["tenantName"];
            this.defaultTenant = _data["defaultTenant"];
            this.language = _data["language"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        data["tenantName"] = this.tenantName;
        data["defaultTenant"] = this.defaultTenant;
        data["language"] = this.language;
        return data;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
    tenantName?: string | undefined;
    defaultTenant?: boolean;
    language?: string | undefined;
}

export class FActionInputDto implements IFActionInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    hashCode?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    featureId?: string | undefined;
    dataCode?: string | undefined;
    fromDataState?: string | undefined;
    toDataState?: string | undefined;
    dataMap?: string | undefined;
    permissions?: string | undefined;

    constructor(data?: IFActionInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.parentId = _data["parentId"];
            this.index = _data["index"];
            this.order = _data["order"];
            this.groupCode = _data["groupCode"];
            this.hashCode = _data["hashCode"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.featureId = _data["featureId"];
            this.dataCode = _data["dataCode"];
            this.fromDataState = _data["fromDataState"];
            this.toDataState = _data["toDataState"];
            this.dataMap = _data["dataMap"];
            this.permissions = _data["permissions"];
        }
    }

    static fromJS(data: any): FActionInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new FActionInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["hashCode"] = this.hashCode;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["featureId"] = this.featureId;
        data["dataCode"] = this.dataCode;
        data["fromDataState"] = this.fromDataState;
        data["toDataState"] = this.toDataState;
        data["dataMap"] = this.dataMap;
        data["permissions"] = this.permissions;
        return data;
    }
}

export interface IFActionInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    hashCode?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    featureId?: string | undefined;
    dataCode?: string | undefined;
    fromDataState?: string | undefined;
    toDataState?: string | undefined;
    dataMap?: string | undefined;
    permissions?: string | undefined;
}

export class FActionOutputDto implements IFActionOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    hashCode?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    featureId?: string | undefined;
    dataCode?: string | undefined;
    fromDataState?: string | undefined;
    toDataState?: string | undefined;
    dataMap?: string | undefined;
    permissions?: string | undefined;
    parentCode?: string | undefined;
    parentName?: string | undefined;

    constructor(data?: IFActionOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.parentId = _data["parentId"];
            this.index = _data["index"];
            this.order = _data["order"];
            this.groupCode = _data["groupCode"];
            this.hashCode = _data["hashCode"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.featureId = _data["featureId"];
            this.dataCode = _data["dataCode"];
            this.fromDataState = _data["fromDataState"];
            this.toDataState = _data["toDataState"];
            this.dataMap = _data["dataMap"];
            this.permissions = _data["permissions"];
            this.parentCode = _data["parentCode"];
            this.parentName = _data["parentName"];
        }
    }

    static fromJS(data: any): FActionOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new FActionOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["hashCode"] = this.hashCode;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["featureId"] = this.featureId;
        data["dataCode"] = this.dataCode;
        data["fromDataState"] = this.fromDataState;
        data["toDataState"] = this.toDataState;
        data["dataMap"] = this.dataMap;
        data["permissions"] = this.permissions;
        data["parentCode"] = this.parentCode;
        data["parentName"] = this.parentName;
        return data;
    }
}

export interface IFActionOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    hashCode?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    featureId?: string | undefined;
    dataCode?: string | undefined;
    fromDataState?: string | undefined;
    toDataState?: string | undefined;
    dataMap?: string | undefined;
    permissions?: string | undefined;
    parentCode?: string | undefined;
    parentName?: string | undefined;
}

export class FActionQueryDto implements IFActionQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: IFActionQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): FActionQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new FActionQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IFActionQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class FeatureInputDto implements IFeatureInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    hashCode?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;

    constructor(data?: IFeatureInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.parentId = _data["parentId"];
            this.index = _data["index"];
            this.order = _data["order"];
            this.groupCode = _data["groupCode"];
            this.hashCode = _data["hashCode"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
        }
    }

    static fromJS(data: any): FeatureInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["hashCode"] = this.hashCode;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        return data;
    }
}

export interface IFeatureInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    hashCode?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
}

export class FeatureOutputDto implements IFeatureOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    hashCode?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    parentCode?: string | undefined;
    parentName?: string | undefined;

    constructor(data?: IFeatureOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.parentId = _data["parentId"];
            this.index = _data["index"];
            this.order = _data["order"];
            this.groupCode = _data["groupCode"];
            this.hashCode = _data["hashCode"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.parentCode = _data["parentCode"];
            this.parentName = _data["parentName"];
        }
    }

    static fromJS(data: any): FeatureOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["hashCode"] = this.hashCode;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["parentCode"] = this.parentCode;
        data["parentName"] = this.parentName;
        return data;
    }
}

export interface IFeatureOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    hashCode?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    parentCode?: string | undefined;
    parentName?: string | undefined;
}

export class FeatureQueryDto implements IFeatureQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: IFeatureQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): FeatureQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IFeatureQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class GetSSOUserDto implements IGetSSOUserDto {
    tenantId?: number | undefined;
    userId?: string | undefined;
    code?: string | undefined;
    useCache?: boolean;

    constructor(data?: IGetSSOUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.code = _data["code"];
            this.useCache = _data["useCache"];
        }
    }

    static fromJS(data: any): GetSSOUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSSOUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["code"] = this.code;
        data["useCache"] = this.useCache;
        return data;
    }
}

export interface IGetSSOUserDto {
    tenantId?: number | undefined;
    userId?: string | undefined;
    code?: string | undefined;
    useCache?: boolean;
}

export class GetSettingDto implements IGetSettingDto {
    tenantId?: number | undefined;
    userId?: string | undefined;
    key?: string | undefined;
    language?: string | undefined;
    type?: string | undefined;
    useCache?: boolean;

    constructor(data?: IGetSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.key = _data["key"];
            this.language = _data["language"];
            this.type = _data["type"];
            this.useCache = _data["useCache"];
        }
    }

    static fromJS(data: any): GetSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["key"] = this.key;
        data["language"] = this.language;
        data["type"] = this.type;
        data["useCache"] = this.useCache;
        return data;
    }
}

export interface IGetSettingDto {
    tenantId?: number | undefined;
    userId?: string | undefined;
    key?: string | undefined;
    language?: string | undefined;
    type?: string | undefined;
    useCache?: boolean;
}

export class HrCompanyInputDto implements IHrCompanyInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    address?: string | undefined;
    dob?: string | undefined;
    note?: string | undefined;
    listIndustry?: string | undefined;
    size?: string | undefined;
    website?: string | undefined;
    logoUrl?: string | undefined;
    description?: string | undefined;

    constructor(data?: IHrCompanyInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this._Name = _data["_Name"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.address = _data["address"];
            this.dob = _data["dob"];
            this.note = _data["note"];
            this.listIndustry = _data["listIndustry"];
            this.size = _data["size"];
            this.website = _data["website"];
            this.logoUrl = _data["logoUrl"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): HrCompanyInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new HrCompanyInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["_Name"] = this._Name;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["address"] = this.address;
        data["dob"] = this.dob;
        data["note"] = this.note;
        data["listIndustry"] = this.listIndustry;
        data["size"] = this.size;
        data["website"] = this.website;
        data["logoUrl"] = this.logoUrl;
        data["description"] = this.description;
        return data;
    }
}

export interface IHrCompanyInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    address?: string | undefined;
    dob?: string | undefined;
    note?: string | undefined;
    listIndustry?: string | undefined;
    size?: string | undefined;
    website?: string | undefined;
    logoUrl?: string | undefined;
    description?: string | undefined;
}

export class HrCompanyOutputDto implements IHrCompanyOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    address?: string | undefined;
    dob?: string | undefined;
    note?: string | undefined;
    listIndustry?: string | undefined;
    size?: string | undefined;
    website?: string | undefined;
    logoUrl?: string | undefined;
    description?: string | undefined;
    numberInterest?: number;

    constructor(data?: IHrCompanyOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this._Name = _data["_Name"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.address = _data["address"];
            this.dob = _data["dob"];
            this.note = _data["note"];
            this.listIndustry = _data["listIndustry"];
            this.size = _data["size"];
            this.website = _data["website"];
            this.logoUrl = _data["logoUrl"];
            this.description = _data["description"];
            this.numberInterest = _data["numberInterest"];
        }
    }

    static fromJS(data: any): HrCompanyOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new HrCompanyOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["_Name"] = this._Name;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["address"] = this.address;
        data["dob"] = this.dob;
        data["note"] = this.note;
        data["listIndustry"] = this.listIndustry;
        data["size"] = this.size;
        data["website"] = this.website;
        data["logoUrl"] = this.logoUrl;
        data["description"] = this.description;
        data["numberInterest"] = this.numberInterest;
        return data;
    }
}

export interface IHrCompanyOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    address?: string | undefined;
    dob?: string | undefined;
    note?: string | undefined;
    listIndustry?: string | undefined;
    size?: string | undefined;
    website?: string | undefined;
    logoUrl?: string | undefined;
    description?: string | undefined;
    numberInterest?: number;
}

export class HrCompanyOutputDtoPagedResultDto implements IHrCompanyOutputDtoPagedResultDto {
    items?: HrCompanyOutputDto[] | undefined;
    totalCount?: number;

    constructor(data?: IHrCompanyOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(HrCompanyOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): HrCompanyOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new HrCompanyOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IHrCompanyOutputDtoPagedResultDto {
    items?: HrCompanyOutputDto[] | undefined;
    totalCount?: number;
}

export class HrCompanyQueryDto implements IHrCompanyQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: IHrCompanyQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): HrCompanyQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new HrCompanyQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IHrCompanyQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class ICriteriaRequestDto implements IICriteriaRequestDto {
    propertyName!: string;
    operation?: OperationCriteria;
    value!: string;

    constructor(data?: IICriteriaRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.operation = _data["operation"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ICriteriaRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ICriteriaRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["operation"] = this.operation;
        data["value"] = this.value;
        return data;
    }
}

export interface IICriteriaRequestDto {
    propertyName: string;
    operation?: OperationCriteria;
    value: string;
}

export class IKeyValueDto implements IIKeyValueDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    entityId?: string | undefined;
    name?: string | undefined;
    type?: string | undefined;
    index?: number;
    value?: string | undefined;
    isDeleted?: boolean;
    creationTime?: Date;
    creationDateTime?: number;

    constructor(data?: IIKeyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.entityId = _data["entityId"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.index = _data["index"];
            this.value = _data["value"];
            this.isDeleted = _data["isDeleted"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
        }
    }

    static fromJS(data: any): IKeyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new IKeyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["entityId"] = this.entityId;
        data["name"] = this.name;
        data["type"] = this.type;
        data["index"] = this.index;
        data["value"] = this.value;
        data["isDeleted"] = this.isDeleted;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        return data;
    }
}

export interface IIKeyValueDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    entityId?: string | undefined;
    name?: string | undefined;
    type?: string | undefined;
    index?: number;
    value?: string | undefined;
    isDeleted?: boolean;
    creationTime?: Date;
    creationDateTime?: number;
}

export class ILanguageValueDto implements IILanguageValueDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    entityId?: string | undefined;
    name?: string | undefined;
    type?: string | undefined;
    index?: number;
    language?: string | undefined;
    value?: string | undefined;
    isDeleted?: boolean;
    creationTime?: Date;
    creationDateTime?: number;

    constructor(data?: IILanguageValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.entityId = _data["entityId"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.index = _data["index"];
            this.language = _data["language"];
            this.value = _data["value"];
            this.isDeleted = _data["isDeleted"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
        }
    }

    static fromJS(data: any): ILanguageValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ILanguageValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["entityId"] = this.entityId;
        data["name"] = this.name;
        data["type"] = this.type;
        data["index"] = this.index;
        data["language"] = this.language;
        data["value"] = this.value;
        data["isDeleted"] = this.isDeleted;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        return data;
    }
}

export interface IILanguageValueDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    entityId?: string | undefined;
    name?: string | undefined;
    type?: string | undefined;
    index?: number;
    language?: string | undefined;
    value?: string | undefined;
    isDeleted?: boolean;
    creationTime?: Date;
    creationDateTime?: number;
}

export class IReferenceDto implements IIReferenceDto {
    tenantId?: number | undefined;
    entityId?: string | undefined;
    keyId?: string | undefined;

    constructor(data?: IIReferenceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.entityId = _data["entityId"];
            this.keyId = _data["keyId"];
        }
    }

    static fromJS(data: any): IReferenceDto {
        data = typeof data === 'object' ? data : {};
        let result = new IReferenceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["entityId"] = this.entityId;
        data["keyId"] = this.keyId;
        return data;
    }
}

export interface IIReferenceDto {
    tenantId?: number | undefined;
    entityId?: string | undefined;
    keyId?: string | undefined;
}

export class InterestInputDto implements IInterestInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    fromUserId?: string | undefined;
    typeFromUser?: string | undefined;
    entityId?: string | undefined;
    typeEntity?: string | undefined;
    typeInterest?: string | undefined;

    constructor(data?: IInterestInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.fromUserId = _data["fromUserId"];
            this.typeFromUser = _data["typeFromUser"];
            this.entityId = _data["entityId"];
            this.typeEntity = _data["typeEntity"];
            this.typeInterest = _data["typeInterest"];
        }
    }

    static fromJS(data: any): InterestInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new InterestInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["fromUserId"] = this.fromUserId;
        data["typeFromUser"] = this.typeFromUser;
        data["entityId"] = this.entityId;
        data["typeEntity"] = this.typeEntity;
        data["typeInterest"] = this.typeInterest;
        return data;
    }
}

export interface IInterestInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    fromUserId?: string | undefined;
    typeFromUser?: string | undefined;
    entityId?: string | undefined;
    typeEntity?: string | undefined;
    typeInterest?: string | undefined;
}

export class InterestOutputDto implements IInterestOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    fromUserId?: string | undefined;
    typeFromUser?: string | undefined;
    entityId?: string | undefined;
    typeEntity?: string | undefined;
    typeInterest?: string | undefined;

    constructor(data?: IInterestOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.fromUserId = _data["fromUserId"];
            this.typeFromUser = _data["typeFromUser"];
            this.entityId = _data["entityId"];
            this.typeEntity = _data["typeEntity"];
            this.typeInterest = _data["typeInterest"];
        }
    }

    static fromJS(data: any): InterestOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new InterestOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["fromUserId"] = this.fromUserId;
        data["typeFromUser"] = this.typeFromUser;
        data["entityId"] = this.entityId;
        data["typeEntity"] = this.typeEntity;
        data["typeInterest"] = this.typeInterest;
        return data;
    }
}

export interface IInterestOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    fromUserId?: string | undefined;
    typeFromUser?: string | undefined;
    entityId?: string | undefined;
    typeEntity?: string | undefined;
    typeInterest?: string | undefined;
}

export class InterestOutputDtoPagedResultDto implements IInterestOutputDtoPagedResultDto {
    items?: InterestOutputDto[] | undefined;
    totalCount?: number;

    constructor(data?: IInterestOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(InterestOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): InterestOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new InterestOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IInterestOutputDtoPagedResultDto {
    items?: InterestOutputDto[] | undefined;
    totalCount?: number;
}

export class InterestQueryDto implements IInterestQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: IInterestQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): InterestQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new InterestQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IInterestQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class InterviewScheduleInputDto implements IInterviewScheduleInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    selectionRoundId?: string | undefined;
    candidateUserId?: string | undefined;
    judgeUserId?: string | undefined;
    start?: Date;
    startTime?: number;
    end?: Date | undefined;
    endTime?: number;
    location?: string | undefined;
    note?: string | undefined;

    constructor(data?: IInterviewScheduleInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.startTime = 0;
            this.endTime = 99999999;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.jobPostId = _data["jobPostId"];
            this.selectionRoundId = _data["selectionRoundId"];
            this.candidateUserId = _data["candidateUserId"];
            this.judgeUserId = _data["judgeUserId"];
            this.start = _data["start"] ? new Date(_data["start"].toString()) : undefined as any;
            this.startTime = _data["startTime"] !== undefined ? _data["startTime"] : 0;
            this.end = _data["end"] ? new Date(_data["end"].toString()) : undefined as any;
            this.endTime = _data["endTime"] !== undefined ? _data["endTime"] : 99999999;
            this.location = _data["location"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): InterviewScheduleInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new InterviewScheduleInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["jobPostId"] = this.jobPostId;
        data["selectionRoundId"] = this.selectionRoundId;
        data["candidateUserId"] = this.candidateUserId;
        data["judgeUserId"] = this.judgeUserId;
        data["start"] = this.start ? this.start.toISOString() : undefined as any;
        data["startTime"] = this.startTime;
        data["end"] = this.end ? this.end.toISOString() : undefined as any;
        data["endTime"] = this.endTime;
        data["location"] = this.location;
        data["note"] = this.note;
        return data;
    }
}

export interface IInterviewScheduleInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    selectionRoundId?: string | undefined;
    candidateUserId?: string | undefined;
    judgeUserId?: string | undefined;
    start?: Date;
    startTime?: number;
    end?: Date | undefined;
    endTime?: number;
    location?: string | undefined;
    note?: string | undefined;
}

export class InterviewScheduleOutputDto implements IInterviewScheduleOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    selectionRoundId?: string | undefined;
    candidateUserId?: string | undefined;
    judgeUserId?: string | undefined;
    start?: Date;
    startTime?: number;
    end?: Date | undefined;
    endTime?: number;
    location?: string | undefined;
    note?: string | undefined;

    constructor(data?: IInterviewScheduleOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.startTime = 0;
            this.endTime = 99999999;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.jobPostId = _data["jobPostId"];
            this.selectionRoundId = _data["selectionRoundId"];
            this.candidateUserId = _data["candidateUserId"];
            this.judgeUserId = _data["judgeUserId"];
            this.start = _data["start"] ? new Date(_data["start"].toString()) : undefined as any;
            this.startTime = _data["startTime"] !== undefined ? _data["startTime"] : 0;
            this.end = _data["end"] ? new Date(_data["end"].toString()) : undefined as any;
            this.endTime = _data["endTime"] !== undefined ? _data["endTime"] : 99999999;
            this.location = _data["location"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): InterviewScheduleOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new InterviewScheduleOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["jobPostId"] = this.jobPostId;
        data["selectionRoundId"] = this.selectionRoundId;
        data["candidateUserId"] = this.candidateUserId;
        data["judgeUserId"] = this.judgeUserId;
        data["start"] = this.start ? this.start.toISOString() : undefined as any;
        data["startTime"] = this.startTime;
        data["end"] = this.end ? this.end.toISOString() : undefined as any;
        data["endTime"] = this.endTime;
        data["location"] = this.location;
        data["note"] = this.note;
        return data;
    }
}

export interface IInterviewScheduleOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    selectionRoundId?: string | undefined;
    candidateUserId?: string | undefined;
    judgeUserId?: string | undefined;
    start?: Date;
    startTime?: number;
    end?: Date | undefined;
    endTime?: number;
    location?: string | undefined;
    note?: string | undefined;
}

export class InterviewScheduleOutputDtoPagedResultDto implements IInterviewScheduleOutputDtoPagedResultDto {
    items?: InterviewScheduleOutputDto[] | undefined;
    totalCount?: number;

    constructor(data?: IInterviewScheduleOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(InterviewScheduleOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): InterviewScheduleOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new InterviewScheduleOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IInterviewScheduleOutputDtoPagedResultDto {
    items?: InterviewScheduleOutputDto[] | undefined;
    totalCount?: number;
}

export class InterviewScheduleQueryDto implements IInterviewScheduleQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: IInterviewScheduleQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): InterviewScheduleQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new InterviewScheduleQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IInterviewScheduleQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class JobApplicationFieldInputDto implements IJobApplicationFieldInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    userProfileId?: string | undefined;
    jobApplicationId?: string | undefined;
    jobPostFieldId?: string | undefined;
    value?: string | undefined;

    constructor(data?: IJobApplicationFieldInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.jobPostId = _data["jobPostId"];
            this.userProfileId = _data["userProfileId"];
            this.jobApplicationId = _data["jobApplicationId"];
            this.jobPostFieldId = _data["jobPostFieldId"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): JobApplicationFieldInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobApplicationFieldInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["jobPostId"] = this.jobPostId;
        data["userProfileId"] = this.userProfileId;
        data["jobApplicationId"] = this.jobApplicationId;
        data["jobPostFieldId"] = this.jobPostFieldId;
        data["value"] = this.value;
        return data;
    }
}

export interface IJobApplicationFieldInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    userProfileId?: string | undefined;
    jobApplicationId?: string | undefined;
    jobPostFieldId?: string | undefined;
    value?: string | undefined;
}

export class JobApplicationFieldOutputDto implements IJobApplicationFieldOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    userProfileId?: string | undefined;
    jobApplicationId?: string | undefined;
    jobPostFieldId?: string | undefined;
    value?: string | undefined;

    constructor(data?: IJobApplicationFieldOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.jobPostId = _data["jobPostId"];
            this.userProfileId = _data["userProfileId"];
            this.jobApplicationId = _data["jobApplicationId"];
            this.jobPostFieldId = _data["jobPostFieldId"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): JobApplicationFieldOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobApplicationFieldOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["jobPostId"] = this.jobPostId;
        data["userProfileId"] = this.userProfileId;
        data["jobApplicationId"] = this.jobApplicationId;
        data["jobPostFieldId"] = this.jobPostFieldId;
        data["value"] = this.value;
        return data;
    }
}

export interface IJobApplicationFieldOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    userProfileId?: string | undefined;
    jobApplicationId?: string | undefined;
    jobPostFieldId?: string | undefined;
    value?: string | undefined;
}

export class JobApplicationFieldOutputDtoPagedResultDto implements IJobApplicationFieldOutputDtoPagedResultDto {
    items?: JobApplicationFieldOutputDto[] | undefined;
    totalCount?: number;

    constructor(data?: IJobApplicationFieldOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(JobApplicationFieldOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): JobApplicationFieldOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobApplicationFieldOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IJobApplicationFieldOutputDtoPagedResultDto {
    items?: JobApplicationFieldOutputDto[] | undefined;
    totalCount?: number;
}

export class JobApplicationFieldQueryDto implements IJobApplicationFieldQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: IJobApplicationFieldQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): JobApplicationFieldQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobApplicationFieldQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IJobApplicationFieldQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class JobApplicationInputDto implements IJobApplicationInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    jobPostId?: string | undefined;
    candidateUserId?: string | undefined;
    resumeUrl?: string | undefined;
    maskedResumeUrl?: string | undefined;
    coverLetter?: string | undefined;
    statusApplication?: string | undefined;
    isAnonymous?: boolean;
    description?: string | undefined;
    note?: string | undefined;
    jobApplicationFields?: JobApplicationFieldInputDto[] | undefined;

    constructor(data?: IJobApplicationInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this._Name = _data["_Name"];
            this.jobPostId = _data["jobPostId"];
            this.candidateUserId = _data["candidateUserId"];
            this.resumeUrl = _data["resumeUrl"];
            this.maskedResumeUrl = _data["maskedResumeUrl"];
            this.coverLetter = _data["coverLetter"];
            this.statusApplication = _data["statusApplication"];
            this.isAnonymous = _data["isAnonymous"];
            this.description = _data["description"];
            this.note = _data["note"];
            if (Array.isArray(_data["jobApplicationFields"])) {
                this.jobApplicationFields = [] as any;
                for (let item of _data["jobApplicationFields"])
                    this.jobApplicationFields!.push(JobApplicationFieldInputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JobApplicationInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobApplicationInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["_Name"] = this._Name;
        data["jobPostId"] = this.jobPostId;
        data["candidateUserId"] = this.candidateUserId;
        data["resumeUrl"] = this.resumeUrl;
        data["maskedResumeUrl"] = this.maskedResumeUrl;
        data["coverLetter"] = this.coverLetter;
        data["statusApplication"] = this.statusApplication;
        data["isAnonymous"] = this.isAnonymous;
        data["description"] = this.description;
        data["note"] = this.note;
        if (Array.isArray(this.jobApplicationFields)) {
            data["jobApplicationFields"] = [];
            for (let item of this.jobApplicationFields)
                data["jobApplicationFields"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IJobApplicationInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    jobPostId?: string | undefined;
    candidateUserId?: string | undefined;
    resumeUrl?: string | undefined;
    maskedResumeUrl?: string | undefined;
    coverLetter?: string | undefined;
    statusApplication?: string | undefined;
    isAnonymous?: boolean;
    description?: string | undefined;
    note?: string | undefined;
    jobApplicationFields?: JobApplicationFieldInputDto[] | undefined;
}

export class JobApplicationOutputDto implements IJobApplicationOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    jobPostId?: string | undefined;
    candidateUserId?: string | undefined;
    resumeUrl?: string | undefined;
    maskedResumeUrl?: string | undefined;
    coverLetter?: string | undefined;
    statusApplication?: string | undefined;
    isAnonymous?: boolean;
    description?: string | undefined;
    note?: string | undefined;
    jobApplicationFields?: JobApplicationFieldOutputDto[] | undefined;

    constructor(data?: IJobApplicationOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this._Name = _data["_Name"];
            this.jobPostId = _data["jobPostId"];
            this.candidateUserId = _data["candidateUserId"];
            this.resumeUrl = _data["resumeUrl"];
            this.maskedResumeUrl = _data["maskedResumeUrl"];
            this.coverLetter = _data["coverLetter"];
            this.statusApplication = _data["statusApplication"];
            this.isAnonymous = _data["isAnonymous"];
            this.description = _data["description"];
            this.note = _data["note"];
            if (Array.isArray(_data["jobApplicationFields"])) {
                this.jobApplicationFields = [] as any;
                for (let item of _data["jobApplicationFields"])
                    this.jobApplicationFields!.push(JobApplicationFieldOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JobApplicationOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobApplicationOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["_Name"] = this._Name;
        data["jobPostId"] = this.jobPostId;
        data["candidateUserId"] = this.candidateUserId;
        data["resumeUrl"] = this.resumeUrl;
        data["maskedResumeUrl"] = this.maskedResumeUrl;
        data["coverLetter"] = this.coverLetter;
        data["statusApplication"] = this.statusApplication;
        data["isAnonymous"] = this.isAnonymous;
        data["description"] = this.description;
        data["note"] = this.note;
        if (Array.isArray(this.jobApplicationFields)) {
            data["jobApplicationFields"] = [];
            for (let item of this.jobApplicationFields)
                data["jobApplicationFields"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IJobApplicationOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    jobPostId?: string | undefined;
    candidateUserId?: string | undefined;
    resumeUrl?: string | undefined;
    maskedResumeUrl?: string | undefined;
    coverLetter?: string | undefined;
    statusApplication?: string | undefined;
    isAnonymous?: boolean;
    description?: string | undefined;
    note?: string | undefined;
    jobApplicationFields?: JobApplicationFieldOutputDto[] | undefined;
}

export class JobApplicationOutputDtoPagedResultDto implements IJobApplicationOutputDtoPagedResultDto {
    items?: JobApplicationOutputDto[] | undefined;
    totalCount?: number;

    constructor(data?: IJobApplicationOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(JobApplicationOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): JobApplicationOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobApplicationOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IJobApplicationOutputDtoPagedResultDto {
    items?: JobApplicationOutputDto[] | undefined;
    totalCount?: number;
}

export class JobApplicationQueryDto implements IJobApplicationQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: IJobApplicationQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): JobApplicationQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobApplicationQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IJobApplicationQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class JobFieldInputDto implements IJobFieldInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    typeCode?: string | undefined;
    label?: string | undefined;
    inputType?: string | undefined;
    defaultValue?: string | undefined;
    listValueOption?: string | undefined;
    css?: string | undefined;
    fomular?: string | undefined;
    dataCode?: string | undefined;
    listRelation?: string | undefined;
    isRequired?: boolean;
    industryId?: string | undefined;
    htmlKey?: string | undefined;
    fieldIndex?: string | undefined;
    groupId?: string | undefined;
    templateId?: string | undefined;
    rowId?: string | undefined;
    columId?: string | undefined;
    isAllowDuplicate?: boolean;
    placeholder?: string | undefined;
    isSearch?: boolean;
    acceptFileExtensions?: string | undefined;
    multiple?: boolean;

    constructor(data?: IJobFieldInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.typeCode = _data["typeCode"];
            this.label = _data["label"];
            this.inputType = _data["inputType"];
            this.defaultValue = _data["defaultValue"];
            this.listValueOption = _data["listValueOption"];
            this.css = _data["css"];
            this.fomular = _data["fomular"];
            this.dataCode = _data["dataCode"];
            this.listRelation = _data["listRelation"];
            this.isRequired = _data["isRequired"];
            this.industryId = _data["industryId"];
            this.htmlKey = _data["htmlKey"];
            this.fieldIndex = _data["fieldIndex"];
            this.groupId = _data["groupId"];
            this.templateId = _data["templateId"];
            this.rowId = _data["rowId"];
            this.columId = _data["columId"];
            this.isAllowDuplicate = _data["isAllowDuplicate"];
            this.placeholder = _data["placeholder"];
            this.isSearch = _data["isSearch"];
            this.acceptFileExtensions = _data["acceptFileExtensions"];
            this.multiple = _data["multiple"];
        }
    }

    static fromJS(data: any): JobFieldInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobFieldInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["typeCode"] = this.typeCode;
        data["label"] = this.label;
        data["inputType"] = this.inputType;
        data["defaultValue"] = this.defaultValue;
        data["listValueOption"] = this.listValueOption;
        data["css"] = this.css;
        data["fomular"] = this.fomular;
        data["dataCode"] = this.dataCode;
        data["listRelation"] = this.listRelation;
        data["isRequired"] = this.isRequired;
        data["industryId"] = this.industryId;
        data["htmlKey"] = this.htmlKey;
        data["fieldIndex"] = this.fieldIndex;
        data["groupId"] = this.groupId;
        data["templateId"] = this.templateId;
        data["rowId"] = this.rowId;
        data["columId"] = this.columId;
        data["isAllowDuplicate"] = this.isAllowDuplicate;
        data["placeholder"] = this.placeholder;
        data["isSearch"] = this.isSearch;
        data["acceptFileExtensions"] = this.acceptFileExtensions;
        data["multiple"] = this.multiple;
        return data;
    }
}

export interface IJobFieldInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    typeCode?: string | undefined;
    label?: string | undefined;
    inputType?: string | undefined;
    defaultValue?: string | undefined;
    listValueOption?: string | undefined;
    css?: string | undefined;
    fomular?: string | undefined;
    dataCode?: string | undefined;
    listRelation?: string | undefined;
    isRequired?: boolean;
    industryId?: string | undefined;
    htmlKey?: string | undefined;
    fieldIndex?: string | undefined;
    groupId?: string | undefined;
    templateId?: string | undefined;
    rowId?: string | undefined;
    columId?: string | undefined;
    isAllowDuplicate?: boolean;
    placeholder?: string | undefined;
    isSearch?: boolean;
    acceptFileExtensions?: string | undefined;
    multiple?: boolean;
}

export class JobFieldOutputDto implements IJobFieldOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    typeCode?: string | undefined;
    label?: string | undefined;
    inputType?: string | undefined;
    defaultValue?: string | undefined;
    listValueOption?: string | undefined;
    css?: string | undefined;
    fomular?: string | undefined;
    dataCode?: string | undefined;
    listRelation?: string | undefined;
    isRequired?: boolean;
    industryId?: string | undefined;
    htmlKey?: string | undefined;
    fieldIndex?: string | undefined;
    groupId?: string | undefined;
    templateId?: string | undefined;
    rowId?: string | undefined;
    columId?: string | undefined;
    isAllowDuplicate?: boolean;
    placeholder?: string | undefined;
    isSearch?: boolean;
    acceptFileExtensions?: string | undefined;
    multiple?: boolean;

    constructor(data?: IJobFieldOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.typeCode = _data["typeCode"];
            this.label = _data["label"];
            this.inputType = _data["inputType"];
            this.defaultValue = _data["defaultValue"];
            this.listValueOption = _data["listValueOption"];
            this.css = _data["css"];
            this.fomular = _data["fomular"];
            this.dataCode = _data["dataCode"];
            this.listRelation = _data["listRelation"];
            this.isRequired = _data["isRequired"];
            this.industryId = _data["industryId"];
            this.htmlKey = _data["htmlKey"];
            this.fieldIndex = _data["fieldIndex"];
            this.groupId = _data["groupId"];
            this.templateId = _data["templateId"];
            this.rowId = _data["rowId"];
            this.columId = _data["columId"];
            this.isAllowDuplicate = _data["isAllowDuplicate"];
            this.placeholder = _data["placeholder"];
            this.isSearch = _data["isSearch"];
            this.acceptFileExtensions = _data["acceptFileExtensions"];
            this.multiple = _data["multiple"];
        }
    }

    static fromJS(data: any): JobFieldOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobFieldOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["typeCode"] = this.typeCode;
        data["label"] = this.label;
        data["inputType"] = this.inputType;
        data["defaultValue"] = this.defaultValue;
        data["listValueOption"] = this.listValueOption;
        data["css"] = this.css;
        data["fomular"] = this.fomular;
        data["dataCode"] = this.dataCode;
        data["listRelation"] = this.listRelation;
        data["isRequired"] = this.isRequired;
        data["industryId"] = this.industryId;
        data["htmlKey"] = this.htmlKey;
        data["fieldIndex"] = this.fieldIndex;
        data["groupId"] = this.groupId;
        data["templateId"] = this.templateId;
        data["rowId"] = this.rowId;
        data["columId"] = this.columId;
        data["isAllowDuplicate"] = this.isAllowDuplicate;
        data["placeholder"] = this.placeholder;
        data["isSearch"] = this.isSearch;
        data["acceptFileExtensions"] = this.acceptFileExtensions;
        data["multiple"] = this.multiple;
        return data;
    }
}

export interface IJobFieldOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    typeCode?: string | undefined;
    label?: string | undefined;
    inputType?: string | undefined;
    defaultValue?: string | undefined;
    listValueOption?: string | undefined;
    css?: string | undefined;
    fomular?: string | undefined;
    dataCode?: string | undefined;
    listRelation?: string | undefined;
    isRequired?: boolean;
    industryId?: string | undefined;
    htmlKey?: string | undefined;
    fieldIndex?: string | undefined;
    groupId?: string | undefined;
    templateId?: string | undefined;
    rowId?: string | undefined;
    columId?: string | undefined;
    isAllowDuplicate?: boolean;
    placeholder?: string | undefined;
    isSearch?: boolean;
    acceptFileExtensions?: string | undefined;
    multiple?: boolean;
}

export class JobFieldOutputDtoPagedResultDto implements IJobFieldOutputDtoPagedResultDto {
    items?: JobFieldOutputDto[] | undefined;
    totalCount?: number;

    constructor(data?: IJobFieldOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(JobFieldOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): JobFieldOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobFieldOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IJobFieldOutputDtoPagedResultDto {
    items?: JobFieldOutputDto[] | undefined;
    totalCount?: number;
}

export class JobFieldQueryDto implements IJobFieldQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: IJobFieldQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): JobFieldQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobFieldQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IJobFieldQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class JobPostFieldInputDto implements IJobPostFieldInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    jobFieldId?: string | undefined;
    typeCode?: string | undefined;
    label?: string | undefined;
    inputType?: string | undefined;
    defaultValue?: string | undefined;
    listValueOption?: string | undefined;
    css?: string | undefined;
    fomular?: string | undefined;
    dataCode?: string | undefined;
    listRelation?: string | undefined;
    isRequired?: boolean;
    industryId?: string | undefined;
    htmlKey?: string | undefined;
    fieldIndex?: string | undefined;
    groupId?: string | undefined;
    templateId?: string | undefined;
    rowId?: string | undefined;
    columId?: string | undefined;
    isAllowDuplicate?: boolean;
    placeholder?: string | undefined;
    isSearch?: boolean;
    acceptFileExtensions?: string | undefined;
    multiple?: boolean;

    constructor(data?: IJobPostFieldInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.jobPostId = _data["jobPostId"];
            this.jobFieldId = _data["jobFieldId"];
            this.typeCode = _data["typeCode"];
            this.label = _data["label"];
            this.inputType = _data["inputType"];
            this.defaultValue = _data["defaultValue"];
            this.listValueOption = _data["listValueOption"];
            this.css = _data["css"];
            this.fomular = _data["fomular"];
            this.dataCode = _data["dataCode"];
            this.listRelation = _data["listRelation"];
            this.isRequired = _data["isRequired"];
            this.industryId = _data["industryId"];
            this.htmlKey = _data["htmlKey"];
            this.fieldIndex = _data["fieldIndex"];
            this.groupId = _data["groupId"];
            this.templateId = _data["templateId"];
            this.rowId = _data["rowId"];
            this.columId = _data["columId"];
            this.isAllowDuplicate = _data["isAllowDuplicate"];
            this.placeholder = _data["placeholder"];
            this.isSearch = _data["isSearch"];
            this.acceptFileExtensions = _data["acceptFileExtensions"];
            this.multiple = _data["multiple"];
        }
    }

    static fromJS(data: any): JobPostFieldInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobPostFieldInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["jobPostId"] = this.jobPostId;
        data["jobFieldId"] = this.jobFieldId;
        data["typeCode"] = this.typeCode;
        data["label"] = this.label;
        data["inputType"] = this.inputType;
        data["defaultValue"] = this.defaultValue;
        data["listValueOption"] = this.listValueOption;
        data["css"] = this.css;
        data["fomular"] = this.fomular;
        data["dataCode"] = this.dataCode;
        data["listRelation"] = this.listRelation;
        data["isRequired"] = this.isRequired;
        data["industryId"] = this.industryId;
        data["htmlKey"] = this.htmlKey;
        data["fieldIndex"] = this.fieldIndex;
        data["groupId"] = this.groupId;
        data["templateId"] = this.templateId;
        data["rowId"] = this.rowId;
        data["columId"] = this.columId;
        data["isAllowDuplicate"] = this.isAllowDuplicate;
        data["placeholder"] = this.placeholder;
        data["isSearch"] = this.isSearch;
        data["acceptFileExtensions"] = this.acceptFileExtensions;
        data["multiple"] = this.multiple;
        return data;
    }
}

export interface IJobPostFieldInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    jobFieldId?: string | undefined;
    typeCode?: string | undefined;
    label?: string | undefined;
    inputType?: string | undefined;
    defaultValue?: string | undefined;
    listValueOption?: string | undefined;
    css?: string | undefined;
    fomular?: string | undefined;
    dataCode?: string | undefined;
    listRelation?: string | undefined;
    isRequired?: boolean;
    industryId?: string | undefined;
    htmlKey?: string | undefined;
    fieldIndex?: string | undefined;
    groupId?: string | undefined;
    templateId?: string | undefined;
    rowId?: string | undefined;
    columId?: string | undefined;
    isAllowDuplicate?: boolean;
    placeholder?: string | undefined;
    isSearch?: boolean;
    acceptFileExtensions?: string | undefined;
    multiple?: boolean;
}

export class JobPostFieldOutputDto implements IJobPostFieldOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    jobFieldId?: string | undefined;
    typeCode?: string | undefined;
    label?: string | undefined;
    inputType?: string | undefined;
    defaultValue?: string | undefined;
    listValueOption?: string | undefined;
    css?: string | undefined;
    fomular?: string | undefined;
    dataCode?: string | undefined;
    listRelation?: string | undefined;
    isRequired?: boolean;
    industryId?: string | undefined;
    htmlKey?: string | undefined;
    fieldIndex?: string | undefined;
    groupId?: string | undefined;
    templateId?: string | undefined;
    rowId?: string | undefined;
    columId?: string | undefined;
    isAllowDuplicate?: boolean;
    placeholder?: string | undefined;
    isSearch?: boolean;
    acceptFileExtensions?: string | undefined;
    multiple?: boolean;

    constructor(data?: IJobPostFieldOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.jobPostId = _data["jobPostId"];
            this.jobFieldId = _data["jobFieldId"];
            this.typeCode = _data["typeCode"];
            this.label = _data["label"];
            this.inputType = _data["inputType"];
            this.defaultValue = _data["defaultValue"];
            this.listValueOption = _data["listValueOption"];
            this.css = _data["css"];
            this.fomular = _data["fomular"];
            this.dataCode = _data["dataCode"];
            this.listRelation = _data["listRelation"];
            this.isRequired = _data["isRequired"];
            this.industryId = _data["industryId"];
            this.htmlKey = _data["htmlKey"];
            this.fieldIndex = _data["fieldIndex"];
            this.groupId = _data["groupId"];
            this.templateId = _data["templateId"];
            this.rowId = _data["rowId"];
            this.columId = _data["columId"];
            this.isAllowDuplicate = _data["isAllowDuplicate"];
            this.placeholder = _data["placeholder"];
            this.isSearch = _data["isSearch"];
            this.acceptFileExtensions = _data["acceptFileExtensions"];
            this.multiple = _data["multiple"];
        }
    }

    static fromJS(data: any): JobPostFieldOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobPostFieldOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["jobPostId"] = this.jobPostId;
        data["jobFieldId"] = this.jobFieldId;
        data["typeCode"] = this.typeCode;
        data["label"] = this.label;
        data["inputType"] = this.inputType;
        data["defaultValue"] = this.defaultValue;
        data["listValueOption"] = this.listValueOption;
        data["css"] = this.css;
        data["fomular"] = this.fomular;
        data["dataCode"] = this.dataCode;
        data["listRelation"] = this.listRelation;
        data["isRequired"] = this.isRequired;
        data["industryId"] = this.industryId;
        data["htmlKey"] = this.htmlKey;
        data["fieldIndex"] = this.fieldIndex;
        data["groupId"] = this.groupId;
        data["templateId"] = this.templateId;
        data["rowId"] = this.rowId;
        data["columId"] = this.columId;
        data["isAllowDuplicate"] = this.isAllowDuplicate;
        data["placeholder"] = this.placeholder;
        data["isSearch"] = this.isSearch;
        data["acceptFileExtensions"] = this.acceptFileExtensions;
        data["multiple"] = this.multiple;
        return data;
    }
}

export interface IJobPostFieldOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    jobFieldId?: string | undefined;
    typeCode?: string | undefined;
    label?: string | undefined;
    inputType?: string | undefined;
    defaultValue?: string | undefined;
    listValueOption?: string | undefined;
    css?: string | undefined;
    fomular?: string | undefined;
    dataCode?: string | undefined;
    listRelation?: string | undefined;
    isRequired?: boolean;
    industryId?: string | undefined;
    htmlKey?: string | undefined;
    fieldIndex?: string | undefined;
    groupId?: string | undefined;
    templateId?: string | undefined;
    rowId?: string | undefined;
    columId?: string | undefined;
    isAllowDuplicate?: boolean;
    placeholder?: string | undefined;
    isSearch?: boolean;
    acceptFileExtensions?: string | undefined;
    multiple?: boolean;
}

export class JobPostFieldOutputDtoPagedResultDto implements IJobPostFieldOutputDtoPagedResultDto {
    items?: JobPostFieldOutputDto[] | undefined;
    totalCount?: number;

    constructor(data?: IJobPostFieldOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(JobPostFieldOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): JobPostFieldOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobPostFieldOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IJobPostFieldOutputDtoPagedResultDto {
    items?: JobPostFieldOutputDto[] | undefined;
    totalCount?: number;
}

export class JobPostFieldQueryDto implements IJobPostFieldQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: IJobPostFieldQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): JobPostFieldQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobPostFieldQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IJobPostFieldQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class JobPostInputDto implements IJobPostInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    title?: string | undefined;
    companyId?: string | undefined;
    companyName?: string | undefined;
    industryId?: string | undefined;
    jobLevel?: string | undefined;
    workingType?: string | undefined;
    experience?: string | undefined;
    position?: string | undefined;
    minimumAge?: string | undefined;
    gender?: string | undefined;
    workingHours?: string | undefined;
    jobDescription?: string | undefined;
    jobRequirements?: string | undefined;
    benefits?: string | undefined;
    note?: string | undefined;
    fromDate?: Date | undefined;
    fromDateTime?: number;
    toDate?: Date | undefined;
    toDateTime?: number;
    applicationDeadline?: Date | undefined;
    applicationDeadlineTime?: number;
    location?: string | undefined;
    quantity?: number;
    salaryMin?: number;
    salaryMax?: number;
    currency?: string | undefined;
    salaryNote?: string | undefined;
    contactEmail?: string | undefined;
    contactPhone?: string | undefined;
    applyLink?: string | undefined;
    jobStatus?: string | undefined;
    referenctJobPostId?: string | undefined;
    typeJobPost?: string | undefined;
    postFileds?: JobPostFieldInputDto[] | undefined;

    constructor(data?: IJobPostInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.fromDateTime = 0;
            this.toDateTime = 99999999;
            this.applicationDeadlineTime = 99999999;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this._Name = _data["_Name"];
            this.title = _data["title"];
            this.companyId = _data["companyId"];
            this.companyName = _data["companyName"];
            this.industryId = _data["industryId"];
            this.jobLevel = _data["jobLevel"];
            this.workingType = _data["workingType"];
            this.experience = _data["experience"];
            this.position = _data["position"];
            this.minimumAge = _data["minimumAge"];
            this.gender = _data["gender"];
            this.workingHours = _data["workingHours"];
            this.jobDescription = _data["jobDescription"];
            this.jobRequirements = _data["jobRequirements"];
            this.benefits = _data["benefits"];
            this.note = _data["note"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : undefined as any;
            this.fromDateTime = _data["fromDateTime"] !== undefined ? _data["fromDateTime"] : 0;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : undefined as any;
            this.toDateTime = _data["toDateTime"] !== undefined ? _data["toDateTime"] : 99999999;
            this.applicationDeadline = _data["applicationDeadline"] ? new Date(_data["applicationDeadline"].toString()) : undefined as any;
            this.applicationDeadlineTime = _data["applicationDeadlineTime"] !== undefined ? _data["applicationDeadlineTime"] : 99999999;
            this.location = _data["location"];
            this.quantity = _data["quantity"];
            this.salaryMin = _data["salaryMin"];
            this.salaryMax = _data["salaryMax"];
            this.currency = _data["currency"];
            this.salaryNote = _data["salaryNote"];
            this.contactEmail = _data["contactEmail"];
            this.contactPhone = _data["contactPhone"];
            this.applyLink = _data["applyLink"];
            this.jobStatus = _data["jobStatus"];
            this.referenctJobPostId = _data["referenctJobPostId"];
            this.typeJobPost = _data["typeJobPost"];
            if (Array.isArray(_data["postFileds"])) {
                this.postFileds = [] as any;
                for (let item of _data["postFileds"])
                    this.postFileds!.push(JobPostFieldInputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JobPostInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobPostInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["_Name"] = this._Name;
        data["title"] = this.title;
        data["companyId"] = this.companyId;
        data["companyName"] = this.companyName;
        data["industryId"] = this.industryId;
        data["jobLevel"] = this.jobLevel;
        data["workingType"] = this.workingType;
        data["experience"] = this.experience;
        data["position"] = this.position;
        data["minimumAge"] = this.minimumAge;
        data["gender"] = this.gender;
        data["workingHours"] = this.workingHours;
        data["jobDescription"] = this.jobDescription;
        data["jobRequirements"] = this.jobRequirements;
        data["benefits"] = this.benefits;
        data["note"] = this.note;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : undefined as any;
        data["fromDateTime"] = this.fromDateTime;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : undefined as any;
        data["toDateTime"] = this.toDateTime;
        data["applicationDeadline"] = this.applicationDeadline ? this.applicationDeadline.toISOString() : undefined as any;
        data["applicationDeadlineTime"] = this.applicationDeadlineTime;
        data["location"] = this.location;
        data["quantity"] = this.quantity;
        data["salaryMin"] = this.salaryMin;
        data["salaryMax"] = this.salaryMax;
        data["currency"] = this.currency;
        data["salaryNote"] = this.salaryNote;
        data["contactEmail"] = this.contactEmail;
        data["contactPhone"] = this.contactPhone;
        data["applyLink"] = this.applyLink;
        data["jobStatus"] = this.jobStatus;
        data["referenctJobPostId"] = this.referenctJobPostId;
        data["typeJobPost"] = this.typeJobPost;
        if (Array.isArray(this.postFileds)) {
            data["postFileds"] = [];
            for (let item of this.postFileds)
                data["postFileds"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IJobPostInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    title?: string | undefined;
    companyId?: string | undefined;
    companyName?: string | undefined;
    industryId?: string | undefined;
    jobLevel?: string | undefined;
    workingType?: string | undefined;
    experience?: string | undefined;
    position?: string | undefined;
    minimumAge?: string | undefined;
    gender?: string | undefined;
    workingHours?: string | undefined;
    jobDescription?: string | undefined;
    jobRequirements?: string | undefined;
    benefits?: string | undefined;
    note?: string | undefined;
    fromDate?: Date | undefined;
    fromDateTime?: number;
    toDate?: Date | undefined;
    toDateTime?: number;
    applicationDeadline?: Date | undefined;
    applicationDeadlineTime?: number;
    location?: string | undefined;
    quantity?: number;
    salaryMin?: number;
    salaryMax?: number;
    currency?: string | undefined;
    salaryNote?: string | undefined;
    contactEmail?: string | undefined;
    contactPhone?: string | undefined;
    applyLink?: string | undefined;
    jobStatus?: string | undefined;
    referenctJobPostId?: string | undefined;
    typeJobPost?: string | undefined;
    postFileds?: JobPostFieldInputDto[] | undefined;
}

export class JobPostOutputDto implements IJobPostOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    title?: string | undefined;
    companyId?: string | undefined;
    companyName?: string | undefined;
    industryId?: string | undefined;
    jobLevel?: string | undefined;
    workingType?: string | undefined;
    experience?: string | undefined;
    position?: string | undefined;
    minimumAge?: string | undefined;
    gender?: string | undefined;
    workingHours?: string | undefined;
    jobDescription?: string | undefined;
    jobRequirements?: string | undefined;
    benefits?: string | undefined;
    note?: string | undefined;
    fromDate?: Date | undefined;
    fromDateTime?: number;
    toDate?: Date | undefined;
    toDateTime?: number;
    applicationDeadline?: Date | undefined;
    applicationDeadlineTime?: number;
    location?: string | undefined;
    quantity?: number;
    salaryMin?: number;
    salaryMax?: number;
    currency?: string | undefined;
    salaryNote?: string | undefined;
    contactEmail?: string | undefined;
    contactPhone?: string | undefined;
    applyLink?: string | undefined;
    jobStatus?: string | undefined;
    referenctJobPostId?: string | undefined;
    typeJobPost?: string | undefined;
    numbeJobApplicationAll?: number;
    numberJobApplicationNew?: number;
    numberSelection?: number;
    numberEvaluation?: number;
    numberView?: number;
    numberInterest?: number;
    postFileds?: JobPostFieldOutputDto[] | undefined;

    constructor(data?: IJobPostOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.fromDateTime = 0;
            this.toDateTime = 99999999;
            this.applicationDeadlineTime = 99999999;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this._Name = _data["_Name"];
            this.title = _data["title"];
            this.companyId = _data["companyId"];
            this.companyName = _data["companyName"];
            this.industryId = _data["industryId"];
            this.jobLevel = _data["jobLevel"];
            this.workingType = _data["workingType"];
            this.experience = _data["experience"];
            this.position = _data["position"];
            this.minimumAge = _data["minimumAge"];
            this.gender = _data["gender"];
            this.workingHours = _data["workingHours"];
            this.jobDescription = _data["jobDescription"];
            this.jobRequirements = _data["jobRequirements"];
            this.benefits = _data["benefits"];
            this.note = _data["note"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : undefined as any;
            this.fromDateTime = _data["fromDateTime"] !== undefined ? _data["fromDateTime"] : 0;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : undefined as any;
            this.toDateTime = _data["toDateTime"] !== undefined ? _data["toDateTime"] : 99999999;
            this.applicationDeadline = _data["applicationDeadline"] ? new Date(_data["applicationDeadline"].toString()) : undefined as any;
            this.applicationDeadlineTime = _data["applicationDeadlineTime"] !== undefined ? _data["applicationDeadlineTime"] : 99999999;
            this.location = _data["location"];
            this.quantity = _data["quantity"];
            this.salaryMin = _data["salaryMin"];
            this.salaryMax = _data["salaryMax"];
            this.currency = _data["currency"];
            this.salaryNote = _data["salaryNote"];
            this.contactEmail = _data["contactEmail"];
            this.contactPhone = _data["contactPhone"];
            this.applyLink = _data["applyLink"];
            this.jobStatus = _data["jobStatus"];
            this.referenctJobPostId = _data["referenctJobPostId"];
            this.typeJobPost = _data["typeJobPost"];
            this.numbeJobApplicationAll = _data["numbeJobApplicationAll"];
            this.numberJobApplicationNew = _data["numberJobApplicationNew"];
            this.numberSelection = _data["numberSelection"];
            this.numberEvaluation = _data["numberEvaluation"];
            this.numberView = _data["numberView"];
            this.numberInterest = _data["numberInterest"];
            if (Array.isArray(_data["postFileds"])) {
                this.postFileds = [] as any;
                for (let item of _data["postFileds"])
                    this.postFileds!.push(JobPostFieldOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JobPostOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobPostOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["_Name"] = this._Name;
        data["title"] = this.title;
        data["companyId"] = this.companyId;
        data["companyName"] = this.companyName;
        data["industryId"] = this.industryId;
        data["jobLevel"] = this.jobLevel;
        data["workingType"] = this.workingType;
        data["experience"] = this.experience;
        data["position"] = this.position;
        data["minimumAge"] = this.minimumAge;
        data["gender"] = this.gender;
        data["workingHours"] = this.workingHours;
        data["jobDescription"] = this.jobDescription;
        data["jobRequirements"] = this.jobRequirements;
        data["benefits"] = this.benefits;
        data["note"] = this.note;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : undefined as any;
        data["fromDateTime"] = this.fromDateTime;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : undefined as any;
        data["toDateTime"] = this.toDateTime;
        data["applicationDeadline"] = this.applicationDeadline ? this.applicationDeadline.toISOString() : undefined as any;
        data["applicationDeadlineTime"] = this.applicationDeadlineTime;
        data["location"] = this.location;
        data["quantity"] = this.quantity;
        data["salaryMin"] = this.salaryMin;
        data["salaryMax"] = this.salaryMax;
        data["currency"] = this.currency;
        data["salaryNote"] = this.salaryNote;
        data["contactEmail"] = this.contactEmail;
        data["contactPhone"] = this.contactPhone;
        data["applyLink"] = this.applyLink;
        data["jobStatus"] = this.jobStatus;
        data["referenctJobPostId"] = this.referenctJobPostId;
        data["typeJobPost"] = this.typeJobPost;
        data["numbeJobApplicationAll"] = this.numbeJobApplicationAll;
        data["numberJobApplicationNew"] = this.numberJobApplicationNew;
        data["numberSelection"] = this.numberSelection;
        data["numberEvaluation"] = this.numberEvaluation;
        data["numberView"] = this.numberView;
        data["numberInterest"] = this.numberInterest;
        if (Array.isArray(this.postFileds)) {
            data["postFileds"] = [];
            for (let item of this.postFileds)
                data["postFileds"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IJobPostOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    title?: string | undefined;
    companyId?: string | undefined;
    companyName?: string | undefined;
    industryId?: string | undefined;
    jobLevel?: string | undefined;
    workingType?: string | undefined;
    experience?: string | undefined;
    position?: string | undefined;
    minimumAge?: string | undefined;
    gender?: string | undefined;
    workingHours?: string | undefined;
    jobDescription?: string | undefined;
    jobRequirements?: string | undefined;
    benefits?: string | undefined;
    note?: string | undefined;
    fromDate?: Date | undefined;
    fromDateTime?: number;
    toDate?: Date | undefined;
    toDateTime?: number;
    applicationDeadline?: Date | undefined;
    applicationDeadlineTime?: number;
    location?: string | undefined;
    quantity?: number;
    salaryMin?: number;
    salaryMax?: number;
    currency?: string | undefined;
    salaryNote?: string | undefined;
    contactEmail?: string | undefined;
    contactPhone?: string | undefined;
    applyLink?: string | undefined;
    jobStatus?: string | undefined;
    referenctJobPostId?: string | undefined;
    typeJobPost?: string | undefined;
    numbeJobApplicationAll?: number;
    numberJobApplicationNew?: number;
    numberSelection?: number;
    numberEvaluation?: number;
    numberView?: number;
    numberInterest?: number;
    postFileds?: JobPostFieldOutputDto[] | undefined;
}

export class JobPostOutputDtoPagedResultDto implements IJobPostOutputDtoPagedResultDto {
    items?: JobPostOutputDto[] | undefined;
    totalCount?: number;

    constructor(data?: IJobPostOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(JobPostOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): JobPostOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobPostOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IJobPostOutputDtoPagedResultDto {
    items?: JobPostOutputDto[] | undefined;
    totalCount?: number;
}

export class JobPostQueryDto implements IJobPostQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: IJobPostQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): JobPostQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobPostQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IJobPostQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class KeyValueDto implements IKeyValueDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    entityId?: string | undefined;
    name?: string | undefined;
    type?: string | undefined;
    index?: number;
    isDeleted?: boolean;
    value?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;

    constructor(data?: IKeyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.entityId = _data["entityId"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.index = _data["index"];
            this.isDeleted = _data["isDeleted"];
            this.value = _data["value"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
        }
    }

    static fromJS(data: any): KeyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["entityId"] = this.entityId;
        data["name"] = this.name;
        data["type"] = this.type;
        data["index"] = this.index;
        data["isDeleted"] = this.isDeleted;
        data["value"] = this.value;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        return data;
    }
}

export interface IKeyValueDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    entityId?: string | undefined;
    name?: string | undefined;
    type?: string | undefined;
    index?: number;
    isDeleted?: boolean;
    value?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
}

export class LanguageValueDto implements ILanguageValueDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    entityId?: string | undefined;
    name?: string | undefined;
    type?: string | undefined;
    index?: number;
    isDeleted?: boolean;
    language?: string | undefined;
    value?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;

    constructor(data?: ILanguageValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.entityId = _data["entityId"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.index = _data["index"];
            this.isDeleted = _data["isDeleted"];
            this.language = _data["language"];
            this.value = _data["value"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
        }
    }

    static fromJS(data: any): LanguageValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["entityId"] = this.entityId;
        data["name"] = this.name;
        data["type"] = this.type;
        data["index"] = this.index;
        data["isDeleted"] = this.isDeleted;
        data["language"] = this.language;
        data["value"] = this.value;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        return data;
    }
}

export interface ILanguageValueDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    entityId?: string | undefined;
    name?: string | undefined;
    type?: string | undefined;
    index?: number;
    isDeleted?: boolean;
    language?: string | undefined;
    value?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
}

export class LogoutDto implements ILogoutDto {
    connectionId?: string | undefined;
    clientAccessToken?: string | undefined;

    constructor(data?: ILogoutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.connectionId = _data["connectionId"];
            this.clientAccessToken = _data["clientAccessToken"];
        }
    }

    static fromJS(data: any): LogoutDto {
        data = typeof data === 'object' ? data : {};
        let result = new LogoutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionId"] = this.connectionId;
        data["clientAccessToken"] = this.clientAccessToken;
        return data;
    }
}

export interface ILogoutDto {
    connectionId?: string | undefined;
    clientAccessToken?: string | undefined;
}

export class MenuInfoDto implements IMenuInfoDto {
    id?: string | undefined;
    parentId?: string | undefined;
    code?: string | undefined;
    hashCode?: string | undefined;
    name?: string | undefined;
    tags?: string | undefined;
    order?: number;
    link?: string | undefined;
    languageValues?: LanguageValueDto[] | undefined;
    keyValues?: KeyValueDto[] | undefined;

    constructor(data?: IMenuInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parentId = _data["parentId"];
            this.code = _data["code"];
            this.hashCode = _data["hashCode"];
            this.name = _data["name"];
            this.tags = _data["tags"];
            this.order = _data["order"];
            this.link = _data["link"];
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(LanguageValueDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(KeyValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MenuInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["hashCode"] = this.hashCode;
        data["name"] = this.name;
        data["tags"] = this.tags;
        data["order"] = this.order;
        data["link"] = this.link;
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IMenuInfoDto {
    id?: string | undefined;
    parentId?: string | undefined;
    code?: string | undefined;
    hashCode?: string | undefined;
    name?: string | undefined;
    tags?: string | undefined;
    order?: number;
    link?: string | undefined;
    languageValues?: LanguageValueDto[] | undefined;
    keyValues?: KeyValueDto[] | undefined;
}

export class MenuInputDto implements IMenuInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    hashCode?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    link?: string | undefined;

    constructor(data?: IMenuInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.parentId = _data["parentId"];
            this.index = _data["index"];
            this.order = _data["order"];
            this.groupCode = _data["groupCode"];
            this.hashCode = _data["hashCode"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.link = _data["link"];
        }
    }

    static fromJS(data: any): MenuInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["hashCode"] = this.hashCode;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["link"] = this.link;
        return data;
    }
}

export interface IMenuInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    hashCode?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    link?: string | undefined;
}

export class MenuOutputDto implements IMenuOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    hashCode?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    link?: string | undefined;
    parentCode?: string | undefined;
    parentName?: string | undefined;

    constructor(data?: IMenuOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.parentId = _data["parentId"];
            this.index = _data["index"];
            this.order = _data["order"];
            this.groupCode = _data["groupCode"];
            this.hashCode = _data["hashCode"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.link = _data["link"];
            this.parentCode = _data["parentCode"];
            this.parentName = _data["parentName"];
        }
    }

    static fromJS(data: any): MenuOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["hashCode"] = this.hashCode;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["link"] = this.link;
        data["parentCode"] = this.parentCode;
        data["parentName"] = this.parentName;
        return data;
    }
}

export interface IMenuOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    hashCode?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    link?: string | undefined;
    parentCode?: string | undefined;
    parentName?: string | undefined;
}

export class MenuQueryDto implements IMenuQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: IMenuQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): MenuQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IMenuQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class MessageInputDto implements IMessageInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    groups?: string | undefined;
    content?: string | undefined;
    note?: string | undefined;
    sendDate?: number;
    config?: string | undefined;
    listAccount?: string | undefined;

    constructor(data?: IMessageInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.groups = _data["groups"];
            this.content = _data["content"];
            this.note = _data["note"];
            this.sendDate = _data["sendDate"];
            this.config = _data["config"];
            this.listAccount = _data["listAccount"];
        }
    }

    static fromJS(data: any): MessageInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["groups"] = this.groups;
        data["content"] = this.content;
        data["note"] = this.note;
        data["sendDate"] = this.sendDate;
        data["config"] = this.config;
        data["listAccount"] = this.listAccount;
        return data;
    }
}

export interface IMessageInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    groups?: string | undefined;
    content?: string | undefined;
    note?: string | undefined;
    sendDate?: number;
    config?: string | undefined;
    listAccount?: string | undefined;
}

export class MessageOutputDto implements IMessageOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    groups?: string | undefined;
    content?: string | undefined;
    note?: string | undefined;
    sendDate?: number;
    config?: string | undefined;
    listAccount?: string | undefined;

    constructor(data?: IMessageOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.groups = _data["groups"];
            this.content = _data["content"];
            this.note = _data["note"];
            this.sendDate = _data["sendDate"];
            this.config = _data["config"];
            this.listAccount = _data["listAccount"];
        }
    }

    static fromJS(data: any): MessageOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["groups"] = this.groups;
        data["content"] = this.content;
        data["note"] = this.note;
        data["sendDate"] = this.sendDate;
        data["config"] = this.config;
        data["listAccount"] = this.listAccount;
        return data;
    }
}

export interface IMessageOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    groups?: string | undefined;
    content?: string | undefined;
    note?: string | undefined;
    sendDate?: number;
    config?: string | undefined;
    listAccount?: string | undefined;
}

export class MessageOutputDtoPagedResultDto implements IMessageOutputDtoPagedResultDto {
    items?: MessageOutputDto[] | undefined;
    totalCount?: number;

    constructor(data?: IMessageOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MessageOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): MessageOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IMessageOutputDtoPagedResultDto {
    items?: MessageOutputDto[] | undefined;
    totalCount?: number;
}

export class MessageQueryDto implements IMessageQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: IMessageQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): MessageQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IMessageQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class NewIdDto implements INewIdDto {
    length?: number;

    constructor(data?: INewIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.length = _data["length"];
        }
    }

    static fromJS(data: any): NewIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new NewIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["length"] = this.length;
        return data;
    }
}

export interface INewIdDto {
    length?: number;
}

export class OTPModel implements IOTPModel {
    userNameOrEmailAddress!: string;
    password!: string;
    type?: string | undefined;

    constructor(data?: IOTPModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): OTPModel {
        data = typeof data === 'object' ? data : {};
        let result = new OTPModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["type"] = this.type;
        return data;
    }
}

export interface IOTPModel {
    userNameOrEmailAddress: string;
    password: string;
    type?: string | undefined;
}

export enum OperationCriteria {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
    _14 = 14,
    _15 = 15,
}

export class OrganizationInputDto implements IOrganizationInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    hashCode?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    organizationTypeId?: string | undefined;
    organizationTypeCode?: string | undefined;

    constructor(data?: IOrganizationInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.parentId = _data["parentId"];
            this.index = _data["index"];
            this.order = _data["order"];
            this.groupCode = _data["groupCode"];
            this.hashCode = _data["hashCode"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.organizationTypeId = _data["organizationTypeId"];
            this.organizationTypeCode = _data["organizationTypeCode"];
        }
    }

    static fromJS(data: any): OrganizationInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["hashCode"] = this.hashCode;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["organizationTypeId"] = this.organizationTypeId;
        data["organizationTypeCode"] = this.organizationTypeCode;
        return data;
    }
}

export interface IOrganizationInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    hashCode?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    organizationTypeId?: string | undefined;
    organizationTypeCode?: string | undefined;
}

export class OrganizationOutputDto implements IOrganizationOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    hashCode?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    organizationTypeId?: string | undefined;
    organizationTypeCode?: string | undefined;
    parentCode?: string | undefined;
    parentName?: string | undefined;
    roles?: RoleOutputDto[] | undefined;

    constructor(data?: IOrganizationOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.parentId = _data["parentId"];
            this.index = _data["index"];
            this.order = _data["order"];
            this.groupCode = _data["groupCode"];
            this.hashCode = _data["hashCode"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.organizationTypeId = _data["organizationTypeId"];
            this.organizationTypeCode = _data["organizationTypeCode"];
            this.parentCode = _data["parentCode"];
            this.parentName = _data["parentName"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(RoleOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["hashCode"] = this.hashCode;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["organizationTypeId"] = this.organizationTypeId;
        data["organizationTypeCode"] = this.organizationTypeCode;
        data["parentCode"] = this.parentCode;
        data["parentName"] = this.parentName;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IOrganizationOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    hashCode?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    organizationTypeId?: string | undefined;
    organizationTypeCode?: string | undefined;
    parentCode?: string | undefined;
    parentName?: string | undefined;
    roles?: RoleOutputDto[] | undefined;
}

export class OrganizationQueryDto implements IOrganizationQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: IOrganizationQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): OrganizationQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IOrganizationQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class OrganizationTypeInputDto implements IOrganizationTypeInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;

    constructor(data?: IOrganizationTypeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
        }
    }

    static fromJS(data: any): OrganizationTypeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationTypeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        return data;
    }
}

export interface IOrganizationTypeInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
}

export class OrganizationTypeOutputDto implements IOrganizationTypeOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;

    constructor(data?: IOrganizationTypeOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
        }
    }

    static fromJS(data: any): OrganizationTypeOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationTypeOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        return data;
    }
}

export interface IOrganizationTypeOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
}

export class OrganizationTypeQueryDto implements IOrganizationTypeQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: IOrganizationTypeQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): OrganizationTypeQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationTypeQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IOrganizationTypeQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class PermissionInputDto implements IPermissionInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    hashCode?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    securityCode?: string | undefined;
    levelCode?: string | undefined;

    constructor(data?: IPermissionInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.parentId = _data["parentId"];
            this.index = _data["index"];
            this.order = _data["order"];
            this.groupCode = _data["groupCode"];
            this.hashCode = _data["hashCode"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.securityCode = _data["securityCode"];
            this.levelCode = _data["levelCode"];
        }
    }

    static fromJS(data: any): PermissionInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["hashCode"] = this.hashCode;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["securityCode"] = this.securityCode;
        data["levelCode"] = this.levelCode;
        return data;
    }
}

export interface IPermissionInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    hashCode?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    securityCode?: string | undefined;
    levelCode?: string | undefined;
}

export class PermissionOutputDto implements IPermissionOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    hashCode?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    securityCode?: string | undefined;
    levelCode?: string | undefined;
    parentCode?: string | undefined;
    parentName?: string | undefined;

    constructor(data?: IPermissionOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.parentId = _data["parentId"];
            this.index = _data["index"];
            this.order = _data["order"];
            this.groupCode = _data["groupCode"];
            this.hashCode = _data["hashCode"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.securityCode = _data["securityCode"];
            this.levelCode = _data["levelCode"];
            this.parentCode = _data["parentCode"];
            this.parentName = _data["parentName"];
        }
    }

    static fromJS(data: any): PermissionOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["hashCode"] = this.hashCode;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["securityCode"] = this.securityCode;
        data["levelCode"] = this.levelCode;
        data["parentCode"] = this.parentCode;
        data["parentName"] = this.parentName;
        return data;
    }
}

export interface IPermissionOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    parentId?: string | undefined;
    index?: number;
    order?: number;
    groupCode?: string | undefined;
    hashCode?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    securityCode?: string | undefined;
    levelCode?: string | undefined;
    parentCode?: string | undefined;
    parentName?: string | undefined;
}

export class PermissionQueryDto implements IPermissionQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: IPermissionQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): PermissionQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IPermissionQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class PostInputDto implements IPostInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    title?: string | undefined;
    content?: string | undefined;
    description?: string | undefined;
    styles?: string | undefined;
    icons?: string | undefined;
    categoryId?: string | undefined;
    categoryCode?: string | undefined;
    fromDate?: Date | undefined;
    fromDateTime?: number;
    toDate?: Date | undefined;
    toDateTime?: number;
    index?: number;

    constructor(data?: IPostInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.fromDateTime = 0;
            this.toDateTime = 99999999;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this._Name = _data["_Name"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.description = _data["description"];
            this.styles = _data["styles"];
            this.icons = _data["icons"];
            this.categoryId = _data["categoryId"];
            this.categoryCode = _data["categoryCode"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : undefined as any;
            this.fromDateTime = _data["fromDateTime"] !== undefined ? _data["fromDateTime"] : 0;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : undefined as any;
            this.toDateTime = _data["toDateTime"] !== undefined ? _data["toDateTime"] : 99999999;
            this.index = _data["index"];
        }
    }

    static fromJS(data: any): PostInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["_Name"] = this._Name;
        data["title"] = this.title;
        data["content"] = this.content;
        data["description"] = this.description;
        data["styles"] = this.styles;
        data["icons"] = this.icons;
        data["categoryId"] = this.categoryId;
        data["categoryCode"] = this.categoryCode;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : undefined as any;
        data["fromDateTime"] = this.fromDateTime;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : undefined as any;
        data["toDateTime"] = this.toDateTime;
        data["index"] = this.index;
        return data;
    }
}

export interface IPostInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    title?: string | undefined;
    content?: string | undefined;
    description?: string | undefined;
    styles?: string | undefined;
    icons?: string | undefined;
    categoryId?: string | undefined;
    categoryCode?: string | undefined;
    fromDate?: Date | undefined;
    fromDateTime?: number;
    toDate?: Date | undefined;
    toDateTime?: number;
    index?: number;
}

export class PostOutputDto implements IPostOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    title?: string | undefined;
    content?: string | undefined;
    description?: string | undefined;
    styles?: string | undefined;
    icons?: string | undefined;
    categoryId?: string | undefined;
    categoryCode?: string | undefined;
    fromDate?: Date | undefined;
    fromDateTime?: number;
    toDate?: Date | undefined;
    toDateTime?: number;
    index?: number;

    constructor(data?: IPostOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.fromDateTime = 0;
            this.toDateTime = 99999999;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this._Name = _data["_Name"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.description = _data["description"];
            this.styles = _data["styles"];
            this.icons = _data["icons"];
            this.categoryId = _data["categoryId"];
            this.categoryCode = _data["categoryCode"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : undefined as any;
            this.fromDateTime = _data["fromDateTime"] !== undefined ? _data["fromDateTime"] : 0;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : undefined as any;
            this.toDateTime = _data["toDateTime"] !== undefined ? _data["toDateTime"] : 99999999;
            this.index = _data["index"];
        }
    }

    static fromJS(data: any): PostOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["_Name"] = this._Name;
        data["title"] = this.title;
        data["content"] = this.content;
        data["description"] = this.description;
        data["styles"] = this.styles;
        data["icons"] = this.icons;
        data["categoryId"] = this.categoryId;
        data["categoryCode"] = this.categoryCode;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : undefined as any;
        data["fromDateTime"] = this.fromDateTime;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : undefined as any;
        data["toDateTime"] = this.toDateTime;
        data["index"] = this.index;
        return data;
    }
}

export interface IPostOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    title?: string | undefined;
    content?: string | undefined;
    description?: string | undefined;
    styles?: string | undefined;
    icons?: string | undefined;
    categoryId?: string | undefined;
    categoryCode?: string | undefined;
    fromDate?: Date | undefined;
    fromDateTime?: number;
    toDate?: Date | undefined;
    toDateTime?: number;
    index?: number;
}

export class PostOutputDtoPagedResultDto implements IPostOutputDtoPagedResultDto {
    items?: PostOutputDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPostOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PostOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PostOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPostOutputDtoPagedResultDto {
    items?: PostOutputDto[] | undefined;
    totalCount?: number;
}

export class PostQueryDto implements IPostQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: IPostQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): PostQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IPostQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class QueryKeyValueDto implements IQueryKeyValueDto {
    key?: string | undefined;
    value?: string | undefined;

    constructor(data?: IQueryKeyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): QueryKeyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new QueryKeyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IQueryKeyValueDto {
    key?: string | undefined;
    value?: string | undefined;
}

export class RegisterInputDto implements IRegisterInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    type?: string | undefined;
    key?: string | undefined;
    value?: string | undefined;
    validations?: string | undefined;

    constructor(data?: IRegisterInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.type = _data["type"];
            this.key = _data["key"];
            this.value = _data["value"];
            this.validations = _data["validations"];
        }
    }

    static fromJS(data: any): RegisterInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["type"] = this.type;
        data["key"] = this.key;
        data["value"] = this.value;
        data["validations"] = this.validations;
        return data;
    }
}

export interface IRegisterInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    type?: string | undefined;
    key?: string | undefined;
    value?: string | undefined;
    validations?: string | undefined;
}

export class RegisterOrganizationUserDto implements IRegisterOrganizationUserDto {
    id?: string | undefined;
    type?: string | undefined;
    tenantId?: number | undefined;
    userId?: string | undefined;
    userName?: string | undefined;
    organizationId?: string | undefined;
    organizationCode?: string | undefined;
    roleId?: string | undefined;
    roleCode?: string | undefined;

    constructor(data?: IRegisterOrganizationUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.organizationId = _data["organizationId"];
            this.organizationCode = _data["organizationCode"];
            this.roleId = _data["roleId"];
            this.roleCode = _data["roleCode"];
        }
    }

    static fromJS(data: any): RegisterOrganizationUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOrganizationUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["organizationId"] = this.organizationId;
        data["organizationCode"] = this.organizationCode;
        data["roleId"] = this.roleId;
        data["roleCode"] = this.roleCode;
        return data;
    }
}

export interface IRegisterOrganizationUserDto {
    id?: string | undefined;
    type?: string | undefined;
    tenantId?: number | undefined;
    userId?: string | undefined;
    userName?: string | undefined;
    organizationId?: string | undefined;
    organizationCode?: string | undefined;
    roleId?: string | undefined;
    roleCode?: string | undefined;
}

export class RegisterOutputDto implements IRegisterOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    type?: string | undefined;
    key?: string | undefined;
    value?: string | undefined;
    validations?: string | undefined;

    constructor(data?: IRegisterOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.type = _data["type"];
            this.key = _data["key"];
            this.value = _data["value"];
            this.validations = _data["validations"];
        }
    }

    static fromJS(data: any): RegisterOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["type"] = this.type;
        data["key"] = this.key;
        data["value"] = this.value;
        data["validations"] = this.validations;
        return data;
    }
}

export interface IRegisterOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    type?: string | undefined;
    key?: string | undefined;
    value?: string | undefined;
    validations?: string | undefined;
}

export class RegisterTenantDto implements IRegisterTenantDto {
    tenantId?: number | undefined;
    tenancyName!: string;
    name!: string;
    domain?: string | undefined;
    emailAddress!: string;
    phoneNumber?: string | undefined;
    password!: string;
    applicationId?: string | undefined;
    language?: string | undefined;

    constructor(data?: IRegisterTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.domain = _data["domain"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.password = _data["password"];
            this.applicationId = _data["applicationId"];
            this.language = _data["language"];
        }
    }

    static fromJS(data: any): RegisterTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["domain"] = this.domain;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["applicationId"] = this.applicationId;
        data["language"] = this.language;
        return data;
    }
}

export interface IRegisterTenantDto {
    tenantId?: number | undefined;
    tenancyName: string;
    name: string;
    domain?: string | undefined;
    emailAddress: string;
    phoneNumber?: string | undefined;
    password: string;
    applicationId?: string | undefined;
    language?: string | undefined;
}

export class RegisterUserDto implements IRegisterUserDto {
    id?: string | undefined;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    tenantId?: number | undefined;
    role?: string | undefined;
    userName!: string;
    name!: string;
    surname?: string | undefined;
    password!: string;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    profiles?: string | undefined;
    contacts?: string | undefined;
    gender?: string | undefined;
    dob?: string | undefined;
    attributes?: string | undefined;

    constructor(data?: IRegisterUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.role = _data["role"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.password = _data["password"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.profiles = _data["profiles"];
            this.contacts = _data["contacts"];
            this.gender = _data["gender"];
            this.dob = _data["dob"];
            this.attributes = _data["attributes"];
        }
    }

    static fromJS(data: any): RegisterUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["tenantId"] = this.tenantId;
        data["role"] = this.role;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["password"] = this.password;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["profiles"] = this.profiles;
        data["contacts"] = this.contacts;
        data["gender"] = this.gender;
        data["dob"] = this.dob;
        data["attributes"] = this.attributes;
        return data;
    }
}

export interface IRegisterUserDto {
    id?: string | undefined;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    tenantId?: number | undefined;
    role?: string | undefined;
    userName: string;
    name: string;
    surname?: string | undefined;
    password: string;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    profiles?: string | undefined;
    contacts?: string | undefined;
    gender?: string | undefined;
    dob?: string | undefined;
    attributes?: string | undefined;
}

export class RegisterUserResultDto implements IRegisterUserResultDto {
    id?: string | undefined;
    userId?: string | undefined;
    tenantId?: number | undefined;
    canLogin?: boolean;
    tenancyName?: string | undefined;
    name?: string | undefined;
    userName?: string | undefined;
    emailAddress?: string | undefined;
    role?: string | undefined;
    gender?: string | undefined;
    dob?: string | undefined;

    constructor(data?: IRegisterUserResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
            this.canLogin = _data["canLogin"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.role = _data["role"];
            this.gender = _data["gender"];
            this.dob = _data["dob"];
        }
    }

    static fromJS(data: any): RegisterUserResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["canLogin"] = this.canLogin;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["role"] = this.role;
        data["gender"] = this.gender;
        data["dob"] = this.dob;
        return data;
    }
}

export interface IRegisterUserResultDto {
    id?: string | undefined;
    userId?: string | undefined;
    tenantId?: number | undefined;
    canLogin?: boolean;
    tenancyName?: string | undefined;
    name?: string | undefined;
    userName?: string | undefined;
    emailAddress?: string | undefined;
    role?: string | undefined;
    gender?: string | undefined;
    dob?: string | undefined;
}

export class RequestEmailConfirmDto implements IRequestEmailConfirmDto {
    name?: string | undefined;
    emailAddress?: string | undefined;
    language?: string | undefined;

    constructor(data?: IRequestEmailConfirmDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.emailAddress = _data["emailAddress"];
            this.language = _data["language"];
        }
    }

    static fromJS(data: any): RequestEmailConfirmDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestEmailConfirmDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["emailAddress"] = this.emailAddress;
        data["language"] = this.language;
        return data;
    }
}

export interface IRequestEmailConfirmDto {
    name?: string | undefined;
    emailAddress?: string | undefined;
    language?: string | undefined;
}

export class RoleInputDto implements IRoleInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    levelCode?: string | undefined;
    permissions?: string | undefined;

    constructor(data?: IRoleInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.levelCode = _data["levelCode"];
            this.permissions = _data["permissions"];
        }
    }

    static fromJS(data: any): RoleInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["levelCode"] = this.levelCode;
        data["permissions"] = this.permissions;
        return data;
    }
}

export interface IRoleInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    levelCode?: string | undefined;
    permissions?: string | undefined;
}

export class RoleOutputDto implements IRoleOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    levelCode?: string | undefined;
    permissions?: string | undefined;

    constructor(data?: IRoleOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.levelCode = _data["levelCode"];
            this.permissions = _data["permissions"];
        }
    }

    static fromJS(data: any): RoleOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["levelCode"] = this.levelCode;
        data["permissions"] = this.permissions;
        return data;
    }
}

export interface IRoleOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    levelCode?: string | undefined;
    permissions?: string | undefined;
}

export class RoleQueryDto implements IRoleQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: IRoleQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): RoleQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IRoleQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class SSOKeyDataDto implements ISSOKeyDataDto {
    entityId?: string | undefined;
    code?: string | undefined;

    constructor(data?: ISSOKeyDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityId = _data["entityId"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): SSOKeyDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new SSOKeyDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityId"] = this.entityId;
        data["code"] = this.code;
        return data;
    }
}

export interface ISSOKeyDataDto {
    entityId?: string | undefined;
    code?: string | undefined;
}

export class SSOPermissionDto implements ISSOPermissionDto {
    id?: string | undefined;
    code?: string | undefined;
    hashCode?: string | undefined;
    levelCode?: string | undefined;
    type?: string | undefined;

    constructor(data?: ISSOPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.hashCode = _data["hashCode"];
            this.levelCode = _data["levelCode"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): SSOPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SSOPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["hashCode"] = this.hashCode;
        data["levelCode"] = this.levelCode;
        data["type"] = this.type;
        return data;
    }
}

export interface ISSOPermissionDto {
    id?: string | undefined;
    code?: string | undefined;
    hashCode?: string | undefined;
    levelCode?: string | undefined;
    type?: string | undefined;
}

export class SSOUserDto implements ISSOUserDto {
    id?: string | undefined;
    tenantId?: number;
    organizations?: SSOUserOrganizationDto[] | undefined;

    constructor(data?: ISSOUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["organizations"])) {
                this.organizations = [] as any;
                for (let item of _data["organizations"])
                    this.organizations!.push(SSOUserOrganizationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SSOUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new SSOUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.organizations)) {
            data["organizations"] = [];
            for (let item of this.organizations)
                data["organizations"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ISSOUserDto {
    id?: string | undefined;
    tenantId?: number;
    organizations?: SSOUserOrganizationDto[] | undefined;
}

export class SSOUserOrganizationDto implements ISSOUserOrganizationDto {
    id?: string | undefined;
    code?: string | undefined;
    hashCode?: string | undefined;
    typeId?: string | undefined;
    typeCode?: string | undefined;
    levelCode?: string | undefined;
    permissions?: SSOPermissionDto[] | undefined;
    keyDatas?: SSOKeyDataDto[] | undefined;

    constructor(data?: ISSOUserOrganizationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.hashCode = _data["hashCode"];
            this.typeId = _data["typeId"];
            this.typeCode = _data["typeCode"];
            this.levelCode = _data["levelCode"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(SSOPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["keyDatas"])) {
                this.keyDatas = [] as any;
                for (let item of _data["keyDatas"])
                    this.keyDatas!.push(SSOKeyDataDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SSOUserOrganizationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SSOUserOrganizationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["hashCode"] = this.hashCode;
        data["typeId"] = this.typeId;
        data["typeCode"] = this.typeCode;
        data["levelCode"] = this.levelCode;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyDatas)) {
            data["keyDatas"] = [];
            for (let item of this.keyDatas)
                data["keyDatas"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ISSOUserOrganizationDto {
    id?: string | undefined;
    code?: string | undefined;
    hashCode?: string | undefined;
    typeId?: string | undefined;
    typeCode?: string | undefined;
    levelCode?: string | undefined;
    permissions?: SSOPermissionDto[] | undefined;
    keyDatas?: SSOKeyDataDto[] | undefined;
}

export class ScheduleInputDto implements IScheduleInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    date?: number;
    time?: number;
    dayOfWeek?: number;
    note?: string | undefined;
    fromDate?: Date | undefined;
    fromDateTime?: number;
    toDate?: Date | undefined;
    toDateTime?: number;
    config?: string | undefined;

    constructor(data?: IScheduleInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.date = _data["date"];
            this.time = _data["time"];
            this.dayOfWeek = _data["dayOfWeek"];
            this.note = _data["note"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : undefined as any;
            this.fromDateTime = _data["fromDateTime"];
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : undefined as any;
            this.toDateTime = _data["toDateTime"];
            this.config = _data["config"];
        }
    }

    static fromJS(data: any): ScheduleInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["date"] = this.date;
        data["time"] = this.time;
        data["dayOfWeek"] = this.dayOfWeek;
        data["note"] = this.note;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : undefined as any;
        data["fromDateTime"] = this.fromDateTime;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : undefined as any;
        data["toDateTime"] = this.toDateTime;
        data["config"] = this.config;
        return data;
    }
}

export interface IScheduleInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    date?: number;
    time?: number;
    dayOfWeek?: number;
    note?: string | undefined;
    fromDate?: Date | undefined;
    fromDateTime?: number;
    toDate?: Date | undefined;
    toDateTime?: number;
    config?: string | undefined;
}

export class ScheduleOutputDto implements IScheduleOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    date?: number;
    time?: number;
    dayOfWeek?: number;
    note?: string | undefined;
    fromDate?: Date | undefined;
    fromDateTime?: number;
    toDate?: Date | undefined;
    toDateTime?: number;
    config?: string | undefined;

    constructor(data?: IScheduleOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.date = _data["date"];
            this.time = _data["time"];
            this.dayOfWeek = _data["dayOfWeek"];
            this.note = _data["note"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : undefined as any;
            this.fromDateTime = _data["fromDateTime"];
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : undefined as any;
            this.toDateTime = _data["toDateTime"];
            this.config = _data["config"];
        }
    }

    static fromJS(data: any): ScheduleOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["date"] = this.date;
        data["time"] = this.time;
        data["dayOfWeek"] = this.dayOfWeek;
        data["note"] = this.note;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : undefined as any;
        data["fromDateTime"] = this.fromDateTime;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : undefined as any;
        data["toDateTime"] = this.toDateTime;
        data["config"] = this.config;
        return data;
    }
}

export interface IScheduleOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    date?: number;
    time?: number;
    dayOfWeek?: number;
    note?: string | undefined;
    fromDate?: Date | undefined;
    fromDateTime?: number;
    toDate?: Date | undefined;
    toDateTime?: number;
    config?: string | undefined;
}

export class ScheduleOutputDtoPagedResultDto implements IScheduleOutputDtoPagedResultDto {
    items?: ScheduleOutputDto[] | undefined;
    totalCount?: number;

    constructor(data?: IScheduleOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ScheduleOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ScheduleOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IScheduleOutputDtoPagedResultDto {
    items?: ScheduleOutputDto[] | undefined;
    totalCount?: number;
}

export class ScheduleQueryDto implements IScheduleQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: IScheduleQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): ScheduleQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IScheduleQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class SelectionCandidateInputDto implements ISelectionCandidateInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    candidateUserId?: string | undefined;
    selectionRoundId?: string | undefined;
    jobApplicationId?: string | undefined;

    constructor(data?: ISelectionCandidateInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.jobPostId = _data["jobPostId"];
            this.candidateUserId = _data["candidateUserId"];
            this.selectionRoundId = _data["selectionRoundId"];
            this.jobApplicationId = _data["jobApplicationId"];
        }
    }

    static fromJS(data: any): SelectionCandidateInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SelectionCandidateInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["jobPostId"] = this.jobPostId;
        data["candidateUserId"] = this.candidateUserId;
        data["selectionRoundId"] = this.selectionRoundId;
        data["jobApplicationId"] = this.jobApplicationId;
        return data;
    }
}

export interface ISelectionCandidateInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    candidateUserId?: string | undefined;
    selectionRoundId?: string | undefined;
    jobApplicationId?: string | undefined;
}

export class SelectionCandidateOutputDto implements ISelectionCandidateOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    candidateUserId?: string | undefined;
    selectionRoundId?: string | undefined;
    jobApplicationId?: string | undefined;

    constructor(data?: ISelectionCandidateOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.jobPostId = _data["jobPostId"];
            this.candidateUserId = _data["candidateUserId"];
            this.selectionRoundId = _data["selectionRoundId"];
            this.jobApplicationId = _data["jobApplicationId"];
        }
    }

    static fromJS(data: any): SelectionCandidateOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SelectionCandidateOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["jobPostId"] = this.jobPostId;
        data["candidateUserId"] = this.candidateUserId;
        data["selectionRoundId"] = this.selectionRoundId;
        data["jobApplicationId"] = this.jobApplicationId;
        return data;
    }
}

export interface ISelectionCandidateOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    candidateUserId?: string | undefined;
    selectionRoundId?: string | undefined;
    jobApplicationId?: string | undefined;
}

export class SelectionCandidateOutputDtoPagedResultDto implements ISelectionCandidateOutputDtoPagedResultDto {
    items?: SelectionCandidateOutputDto[] | undefined;
    totalCount?: number;

    constructor(data?: ISelectionCandidateOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SelectionCandidateOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SelectionCandidateOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SelectionCandidateOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface ISelectionCandidateOutputDtoPagedResultDto {
    items?: SelectionCandidateOutputDto[] | undefined;
    totalCount?: number;
}

export class SelectionCandidateQueryDto implements ISelectionCandidateQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: ISelectionCandidateQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): SelectionCandidateQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new SelectionCandidateQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ISelectionCandidateQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class SelectionFieldInputDto implements ISelectionFieldInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    jobPostFieldId?: string | undefined;
    jobFieldId?: string | undefined;
    selectionRoundId?: string | undefined;
    typeCode?: string | undefined;
    label?: string | undefined;
    inputType?: string | undefined;
    defaultValue?: string | undefined;
    listValueOption?: string | undefined;
    css?: string | undefined;
    fomular?: string | undefined;
    dataCode?: string | undefined;
    listRelation?: string | undefined;
    isRequired?: boolean;
    industryId?: string | undefined;
    htmlKey?: string | undefined;
    fieldIndex?: string | undefined;
    groupId?: string | undefined;
    templateId?: string | undefined;
    rowId?: string | undefined;
    columId?: string | undefined;
    isAllowDuplicate?: boolean;
    placeholder?: string | undefined;
    isSearch?: boolean;
    acceptFileExtensions?: string | undefined;
    multiple?: boolean;

    constructor(data?: ISelectionFieldInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.jobPostId = _data["jobPostId"];
            this.jobPostFieldId = _data["jobPostFieldId"];
            this.jobFieldId = _data["jobFieldId"];
            this.selectionRoundId = _data["selectionRoundId"];
            this.typeCode = _data["typeCode"];
            this.label = _data["label"];
            this.inputType = _data["inputType"];
            this.defaultValue = _data["defaultValue"];
            this.listValueOption = _data["listValueOption"];
            this.css = _data["css"];
            this.fomular = _data["fomular"];
            this.dataCode = _data["dataCode"];
            this.listRelation = _data["listRelation"];
            this.isRequired = _data["isRequired"];
            this.industryId = _data["industryId"];
            this.htmlKey = _data["htmlKey"];
            this.fieldIndex = _data["fieldIndex"];
            this.groupId = _data["groupId"];
            this.templateId = _data["templateId"];
            this.rowId = _data["rowId"];
            this.columId = _data["columId"];
            this.isAllowDuplicate = _data["isAllowDuplicate"];
            this.placeholder = _data["placeholder"];
            this.isSearch = _data["isSearch"];
            this.acceptFileExtensions = _data["acceptFileExtensions"];
            this.multiple = _data["multiple"];
        }
    }

    static fromJS(data: any): SelectionFieldInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SelectionFieldInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["jobPostId"] = this.jobPostId;
        data["jobPostFieldId"] = this.jobPostFieldId;
        data["jobFieldId"] = this.jobFieldId;
        data["selectionRoundId"] = this.selectionRoundId;
        data["typeCode"] = this.typeCode;
        data["label"] = this.label;
        data["inputType"] = this.inputType;
        data["defaultValue"] = this.defaultValue;
        data["listValueOption"] = this.listValueOption;
        data["css"] = this.css;
        data["fomular"] = this.fomular;
        data["dataCode"] = this.dataCode;
        data["listRelation"] = this.listRelation;
        data["isRequired"] = this.isRequired;
        data["industryId"] = this.industryId;
        data["htmlKey"] = this.htmlKey;
        data["fieldIndex"] = this.fieldIndex;
        data["groupId"] = this.groupId;
        data["templateId"] = this.templateId;
        data["rowId"] = this.rowId;
        data["columId"] = this.columId;
        data["isAllowDuplicate"] = this.isAllowDuplicate;
        data["placeholder"] = this.placeholder;
        data["isSearch"] = this.isSearch;
        data["acceptFileExtensions"] = this.acceptFileExtensions;
        data["multiple"] = this.multiple;
        return data;
    }
}

export interface ISelectionFieldInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    jobPostFieldId?: string | undefined;
    jobFieldId?: string | undefined;
    selectionRoundId?: string | undefined;
    typeCode?: string | undefined;
    label?: string | undefined;
    inputType?: string | undefined;
    defaultValue?: string | undefined;
    listValueOption?: string | undefined;
    css?: string | undefined;
    fomular?: string | undefined;
    dataCode?: string | undefined;
    listRelation?: string | undefined;
    isRequired?: boolean;
    industryId?: string | undefined;
    htmlKey?: string | undefined;
    fieldIndex?: string | undefined;
    groupId?: string | undefined;
    templateId?: string | undefined;
    rowId?: string | undefined;
    columId?: string | undefined;
    isAllowDuplicate?: boolean;
    placeholder?: string | undefined;
    isSearch?: boolean;
    acceptFileExtensions?: string | undefined;
    multiple?: boolean;
}

export class SelectionFieldOutputDto implements ISelectionFieldOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    jobPostFieldId?: string | undefined;
    jobFieldId?: string | undefined;
    selectionRoundId?: string | undefined;
    typeCode?: string | undefined;
    label?: string | undefined;
    inputType?: string | undefined;
    defaultValue?: string | undefined;
    listValueOption?: string | undefined;
    css?: string | undefined;
    fomular?: string | undefined;
    dataCode?: string | undefined;
    listRelation?: string | undefined;
    isRequired?: boolean;
    industryId?: string | undefined;
    htmlKey?: string | undefined;
    fieldIndex?: string | undefined;
    groupId?: string | undefined;
    templateId?: string | undefined;
    rowId?: string | undefined;
    columId?: string | undefined;
    isAllowDuplicate?: boolean;
    placeholder?: string | undefined;
    isSearch?: boolean;
    acceptFileExtensions?: string | undefined;
    multiple?: boolean;

    constructor(data?: ISelectionFieldOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.jobPostId = _data["jobPostId"];
            this.jobPostFieldId = _data["jobPostFieldId"];
            this.jobFieldId = _data["jobFieldId"];
            this.selectionRoundId = _data["selectionRoundId"];
            this.typeCode = _data["typeCode"];
            this.label = _data["label"];
            this.inputType = _data["inputType"];
            this.defaultValue = _data["defaultValue"];
            this.listValueOption = _data["listValueOption"];
            this.css = _data["css"];
            this.fomular = _data["fomular"];
            this.dataCode = _data["dataCode"];
            this.listRelation = _data["listRelation"];
            this.isRequired = _data["isRequired"];
            this.industryId = _data["industryId"];
            this.htmlKey = _data["htmlKey"];
            this.fieldIndex = _data["fieldIndex"];
            this.groupId = _data["groupId"];
            this.templateId = _data["templateId"];
            this.rowId = _data["rowId"];
            this.columId = _data["columId"];
            this.isAllowDuplicate = _data["isAllowDuplicate"];
            this.placeholder = _data["placeholder"];
            this.isSearch = _data["isSearch"];
            this.acceptFileExtensions = _data["acceptFileExtensions"];
            this.multiple = _data["multiple"];
        }
    }

    static fromJS(data: any): SelectionFieldOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SelectionFieldOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["jobPostId"] = this.jobPostId;
        data["jobPostFieldId"] = this.jobPostFieldId;
        data["jobFieldId"] = this.jobFieldId;
        data["selectionRoundId"] = this.selectionRoundId;
        data["typeCode"] = this.typeCode;
        data["label"] = this.label;
        data["inputType"] = this.inputType;
        data["defaultValue"] = this.defaultValue;
        data["listValueOption"] = this.listValueOption;
        data["css"] = this.css;
        data["fomular"] = this.fomular;
        data["dataCode"] = this.dataCode;
        data["listRelation"] = this.listRelation;
        data["isRequired"] = this.isRequired;
        data["industryId"] = this.industryId;
        data["htmlKey"] = this.htmlKey;
        data["fieldIndex"] = this.fieldIndex;
        data["groupId"] = this.groupId;
        data["templateId"] = this.templateId;
        data["rowId"] = this.rowId;
        data["columId"] = this.columId;
        data["isAllowDuplicate"] = this.isAllowDuplicate;
        data["placeholder"] = this.placeholder;
        data["isSearch"] = this.isSearch;
        data["acceptFileExtensions"] = this.acceptFileExtensions;
        data["multiple"] = this.multiple;
        return data;
    }
}

export interface ISelectionFieldOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    jobPostFieldId?: string | undefined;
    jobFieldId?: string | undefined;
    selectionRoundId?: string | undefined;
    typeCode?: string | undefined;
    label?: string | undefined;
    inputType?: string | undefined;
    defaultValue?: string | undefined;
    listValueOption?: string | undefined;
    css?: string | undefined;
    fomular?: string | undefined;
    dataCode?: string | undefined;
    listRelation?: string | undefined;
    isRequired?: boolean;
    industryId?: string | undefined;
    htmlKey?: string | undefined;
    fieldIndex?: string | undefined;
    groupId?: string | undefined;
    templateId?: string | undefined;
    rowId?: string | undefined;
    columId?: string | undefined;
    isAllowDuplicate?: boolean;
    placeholder?: string | undefined;
    isSearch?: boolean;
    acceptFileExtensions?: string | undefined;
    multiple?: boolean;
}

export class SelectionFieldOutputDtoPagedResultDto implements ISelectionFieldOutputDtoPagedResultDto {
    items?: SelectionFieldOutputDto[] | undefined;
    totalCount?: number;

    constructor(data?: ISelectionFieldOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SelectionFieldOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SelectionFieldOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SelectionFieldOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface ISelectionFieldOutputDtoPagedResultDto {
    items?: SelectionFieldOutputDto[] | undefined;
    totalCount?: number;
}

export class SelectionFieldQueryDto implements ISelectionFieldQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: ISelectionFieldQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): SelectionFieldQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new SelectionFieldQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ISelectionFieldQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class SelectionJudgeInputDto implements ISelectionJudgeInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    selectionRoundId?: string | undefined;
    userId?: string | undefined;

    constructor(data?: ISelectionJudgeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.jobPostId = _data["jobPostId"];
            this.selectionRoundId = _data["selectionRoundId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): SelectionJudgeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SelectionJudgeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["jobPostId"] = this.jobPostId;
        data["selectionRoundId"] = this.selectionRoundId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface ISelectionJudgeInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    selectionRoundId?: string | undefined;
    userId?: string | undefined;
}

export class SelectionJudgeOutputDto implements ISelectionJudgeOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    selectionRoundId?: string | undefined;
    userId?: string | undefined;

    constructor(data?: ISelectionJudgeOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.jobPostId = _data["jobPostId"];
            this.selectionRoundId = _data["selectionRoundId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): SelectionJudgeOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SelectionJudgeOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["jobPostId"] = this.jobPostId;
        data["selectionRoundId"] = this.selectionRoundId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface ISelectionJudgeOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    jobPostId?: string | undefined;
    selectionRoundId?: string | undefined;
    userId?: string | undefined;
}

export class SelectionJudgeOutputDtoPagedResultDto implements ISelectionJudgeOutputDtoPagedResultDto {
    items?: SelectionJudgeOutputDto[] | undefined;
    totalCount?: number;

    constructor(data?: ISelectionJudgeOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SelectionJudgeOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SelectionJudgeOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SelectionJudgeOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface ISelectionJudgeOutputDtoPagedResultDto {
    items?: SelectionJudgeOutputDto[] | undefined;
    totalCount?: number;
}

export class SelectionJudgeQueryDto implements ISelectionJudgeQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: ISelectionJudgeQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): SelectionJudgeQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new SelectionJudgeQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ISelectionJudgeQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class SelectionRoundInputDto implements ISelectionRoundInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    jobPostId?: string | undefined;
    stageOrder?: number;
    isFinalStage?: boolean;
    title?: string | undefined;
    content?: string | undefined;
    description?: string | undefined;
    dateRound?: Date | undefined;
    dateRoundTime?: number;
    candidates?: SelectionCandidateInputDto[] | undefined;
    judges?: SelectionJudgeInputDto[] | undefined;
    selectionFields?: SelectionFieldInputDto[] | undefined;

    constructor(data?: ISelectionRoundInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.dateRoundTime = 0;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this._Name = _data["_Name"];
            this.jobPostId = _data["jobPostId"];
            this.stageOrder = _data["stageOrder"];
            this.isFinalStage = _data["isFinalStage"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.description = _data["description"];
            this.dateRound = _data["dateRound"] ? new Date(_data["dateRound"].toString()) : undefined as any;
            this.dateRoundTime = _data["dateRoundTime"] !== undefined ? _data["dateRoundTime"] : 0;
            if (Array.isArray(_data["candidates"])) {
                this.candidates = [] as any;
                for (let item of _data["candidates"])
                    this.candidates!.push(SelectionCandidateInputDto.fromJS(item));
            }
            if (Array.isArray(_data["judges"])) {
                this.judges = [] as any;
                for (let item of _data["judges"])
                    this.judges!.push(SelectionJudgeInputDto.fromJS(item));
            }
            if (Array.isArray(_data["selectionFields"])) {
                this.selectionFields = [] as any;
                for (let item of _data["selectionFields"])
                    this.selectionFields!.push(SelectionFieldInputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SelectionRoundInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SelectionRoundInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["_Name"] = this._Name;
        data["jobPostId"] = this.jobPostId;
        data["stageOrder"] = this.stageOrder;
        data["isFinalStage"] = this.isFinalStage;
        data["title"] = this.title;
        data["content"] = this.content;
        data["description"] = this.description;
        data["dateRound"] = this.dateRound ? this.dateRound.toISOString() : undefined as any;
        data["dateRoundTime"] = this.dateRoundTime;
        if (Array.isArray(this.candidates)) {
            data["candidates"] = [];
            for (let item of this.candidates)
                data["candidates"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.judges)) {
            data["judges"] = [];
            for (let item of this.judges)
                data["judges"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.selectionFields)) {
            data["selectionFields"] = [];
            for (let item of this.selectionFields)
                data["selectionFields"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ISelectionRoundInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    jobPostId?: string | undefined;
    stageOrder?: number;
    isFinalStage?: boolean;
    title?: string | undefined;
    content?: string | undefined;
    description?: string | undefined;
    dateRound?: Date | undefined;
    dateRoundTime?: number;
    candidates?: SelectionCandidateInputDto[] | undefined;
    judges?: SelectionJudgeInputDto[] | undefined;
    selectionFields?: SelectionFieldInputDto[] | undefined;
}

export class SelectionRoundOutputDto implements ISelectionRoundOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    jobPostId?: string | undefined;
    stageOrder?: number;
    isFinalStage?: boolean;
    title?: string | undefined;
    content?: string | undefined;
    description?: string | undefined;
    dateRound?: Date | undefined;
    dateRoundTime?: number;
    candidates?: SelectionCandidateOutputDto[] | undefined;
    judges?: SelectionJudgeOutputDto[] | undefined;
    selectionFields?: SelectionFieldOutputDto[] | undefined;

    constructor(data?: ISelectionRoundOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.dateRoundTime = 0;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this._Name = _data["_Name"];
            this.jobPostId = _data["jobPostId"];
            this.stageOrder = _data["stageOrder"];
            this.isFinalStage = _data["isFinalStage"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.description = _data["description"];
            this.dateRound = _data["dateRound"] ? new Date(_data["dateRound"].toString()) : undefined as any;
            this.dateRoundTime = _data["dateRoundTime"] !== undefined ? _data["dateRoundTime"] : 0;
            if (Array.isArray(_data["candidates"])) {
                this.candidates = [] as any;
                for (let item of _data["candidates"])
                    this.candidates!.push(SelectionCandidateOutputDto.fromJS(item));
            }
            if (Array.isArray(_data["judges"])) {
                this.judges = [] as any;
                for (let item of _data["judges"])
                    this.judges!.push(SelectionJudgeOutputDto.fromJS(item));
            }
            if (Array.isArray(_data["selectionFields"])) {
                this.selectionFields = [] as any;
                for (let item of _data["selectionFields"])
                    this.selectionFields!.push(SelectionFieldOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SelectionRoundOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SelectionRoundOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["_Name"] = this._Name;
        data["jobPostId"] = this.jobPostId;
        data["stageOrder"] = this.stageOrder;
        data["isFinalStage"] = this.isFinalStage;
        data["title"] = this.title;
        data["content"] = this.content;
        data["description"] = this.description;
        data["dateRound"] = this.dateRound ? this.dateRound.toISOString() : undefined as any;
        data["dateRoundTime"] = this.dateRoundTime;
        if (Array.isArray(this.candidates)) {
            data["candidates"] = [];
            for (let item of this.candidates)
                data["candidates"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.judges)) {
            data["judges"] = [];
            for (let item of this.judges)
                data["judges"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.selectionFields)) {
            data["selectionFields"] = [];
            for (let item of this.selectionFields)
                data["selectionFields"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ISelectionRoundOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    jobPostId?: string | undefined;
    stageOrder?: number;
    isFinalStage?: boolean;
    title?: string | undefined;
    content?: string | undefined;
    description?: string | undefined;
    dateRound?: Date | undefined;
    dateRoundTime?: number;
    candidates?: SelectionCandidateOutputDto[] | undefined;
    judges?: SelectionJudgeOutputDto[] | undefined;
    selectionFields?: SelectionFieldOutputDto[] | undefined;
}

export class SelectionRoundOutputDtoPagedResultDto implements ISelectionRoundOutputDtoPagedResultDto {
    items?: SelectionRoundOutputDto[] | undefined;
    totalCount?: number;

    constructor(data?: ISelectionRoundOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SelectionRoundOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SelectionRoundOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SelectionRoundOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface ISelectionRoundOutputDtoPagedResultDto {
    items?: SelectionRoundOutputDto[] | undefined;
    totalCount?: number;
}

export class SelectionRoundQueryDto implements ISelectionRoundQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: ISelectionRoundQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): SelectionRoundQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new SelectionRoundQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ISelectionRoundQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class SendMessageResultDto implements ISendMessageResultDto {
    receivers?: ConnectionUserDto[] | undefined;
    signalRReceivers?: ConnectionUserDto[] | undefined;
    pushReceivers?: ConnectionUserDto[] | undefined;

    constructor(data?: ISendMessageResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["receivers"])) {
                this.receivers = [] as any;
                for (let item of _data["receivers"])
                    this.receivers!.push(ConnectionUserDto.fromJS(item));
            }
            if (Array.isArray(_data["signalRReceivers"])) {
                this.signalRReceivers = [] as any;
                for (let item of _data["signalRReceivers"])
                    this.signalRReceivers!.push(ConnectionUserDto.fromJS(item));
            }
            if (Array.isArray(_data["pushReceivers"])) {
                this.pushReceivers = [] as any;
                for (let item of _data["pushReceivers"])
                    this.pushReceivers!.push(ConnectionUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SendMessageResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendMessageResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.receivers)) {
            data["receivers"] = [];
            for (let item of this.receivers)
                data["receivers"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.signalRReceivers)) {
            data["signalRReceivers"] = [];
            for (let item of this.signalRReceivers)
                data["signalRReceivers"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.pushReceivers)) {
            data["pushReceivers"] = [];
            for (let item of this.pushReceivers)
                data["pushReceivers"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ISendMessageResultDto {
    receivers?: ConnectionUserDto[] | undefined;
    signalRReceivers?: ConnectionUserDto[] | undefined;
    pushReceivers?: ConnectionUserDto[] | undefined;
}

export class SendMessagesDto implements ISendMessagesDto {
    sender?: ConnectionUserDto;
    receiverDtos?: ConnectionUserDto[] | undefined;
    channelId?: string | undefined;
    title?: string | undefined;
    message?: string | undefined;

    constructor(data?: ISendMessagesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sender = _data["sender"] ? ConnectionUserDto.fromJS(_data["sender"]) : undefined as any;
            if (Array.isArray(_data["receiverDtos"])) {
                this.receiverDtos = [] as any;
                for (let item of _data["receiverDtos"])
                    this.receiverDtos!.push(ConnectionUserDto.fromJS(item));
            }
            this.channelId = _data["channelId"];
            this.title = _data["title"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): SendMessagesDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendMessagesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sender"] = this.sender ? this.sender.toJSON() : undefined as any;
        if (Array.isArray(this.receiverDtos)) {
            data["receiverDtos"] = [];
            for (let item of this.receiverDtos)
                data["receiverDtos"].push(item ? item.toJSON() : undefined as any);
        }
        data["channelId"] = this.channelId;
        data["title"] = this.title;
        data["message"] = this.message;
        return data;
    }
}

export interface ISendMessagesDto {
    sender?: ConnectionUserDto;
    receiverDtos?: ConnectionUserDto[] | undefined;
    channelId?: string | undefined;
    title?: string | undefined;
    message?: string | undefined;
}

export class SetDefaultTenantDto implements ISetDefaultTenantDto {
    tenantId?: number;
    userId?: string | undefined;
    code?: string | undefined;

    constructor(data?: ISetDefaultTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): SetDefaultTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["code"] = this.code;
        return data;
    }
}

export interface ISetDefaultTenantDto {
    tenantId?: number;
    userId?: string | undefined;
    code?: string | undefined;
}

export class SetStatusUsersInputDto implements ISetStatusUsersInputDto {
    status?: string | undefined;
    listUser?: StringEntityDto[] | undefined;

    constructor(data?: ISetStatusUsersInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            if (Array.isArray(_data["listUser"])) {
                this.listUser = [] as any;
                for (let item of _data["listUser"])
                    this.listUser!.push(StringEntityDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SetStatusUsersInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetStatusUsersInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        if (Array.isArray(this.listUser)) {
            data["listUser"] = [];
            for (let item of this.listUser)
                data["listUser"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ISetStatusUsersInputDto {
    status?: string | undefined;
    listUser?: StringEntityDto[] | undefined;
}

export class SetUserOrganizationDto implements ISetUserOrganizationDto {
    tenantId?: number | undefined;
    userId?: string | undefined;
    organizations?: UserOrganizationsDto[] | undefined;
    status?: string | undefined;

    constructor(data?: ISetUserOrganizationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["organizations"])) {
                this.organizations = [] as any;
                for (let item of _data["organizations"])
                    this.organizations!.push(UserOrganizationsDto.fromJS(item));
            }
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): SetUserOrganizationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetUserOrganizationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        if (Array.isArray(this.organizations)) {
            data["organizations"] = [];
            for (let item of this.organizations)
                data["organizations"].push(item ? item.toJSON() : undefined as any);
        }
        data["status"] = this.status;
        return data;
    }
}

export interface ISetUserOrganizationDto {
    tenantId?: number | undefined;
    userId?: string | undefined;
    organizations?: UserOrganizationsDto[] | undefined;
    status?: string | undefined;
}

export class SetUsersInputDto implements ISetUsersInputDto {
    defaultPassword?: string | undefined;
    listUser?: UserInputDto[] | undefined;

    constructor(data?: ISetUsersInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultPassword = _data["defaultPassword"];
            if (Array.isArray(_data["listUser"])) {
                this.listUser = [] as any;
                for (let item of _data["listUser"])
                    this.listUser!.push(UserInputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SetUsersInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetUsersInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultPassword"] = this.defaultPassword;
        if (Array.isArray(this.listUser)) {
            data["listUser"] = [];
            for (let item of this.listUser)
                data["listUser"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ISetUsersInputDto {
    defaultPassword?: string | undefined;
    listUser?: UserInputDto[] | undefined;
}

export class SettingEntityQueryDto implements ISettingEntityQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: ISettingEntityQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): SettingEntityQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingEntityQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface ISettingEntityQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class SettingInputDto implements ISettingInputDto {
    id?: string | undefined;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    tenantId?: number | undefined;
    userId?: string | undefined;
    key?: string | undefined;
    type?: string | undefined;
    value?: string | undefined;
    attributes?: string | undefined;
    tags?: string | undefined;
    language?: string | undefined;

    constructor(data?: ISettingInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.key = _data["key"];
            this.type = _data["type"];
            this.value = _data["value"];
            this.attributes = _data["attributes"];
            this.tags = _data["tags"];
            this.language = _data["language"];
        }
    }

    static fromJS(data: any): SettingInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["key"] = this.key;
        data["type"] = this.type;
        data["value"] = this.value;
        data["attributes"] = this.attributes;
        data["tags"] = this.tags;
        data["language"] = this.language;
        return data;
    }
}

export interface ISettingInputDto {
    id?: string | undefined;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    tenantId?: number | undefined;
    userId?: string | undefined;
    key?: string | undefined;
    type?: string | undefined;
    value?: string | undefined;
    attributes?: string | undefined;
    tags?: string | undefined;
    language?: string | undefined;
}

export class SettingOutputDto implements ISettingOutputDto {
    id?: string | undefined;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    tenantId?: number | undefined;
    userId?: string | undefined;
    key?: string | undefined;
    type?: string | undefined;
    value?: string | undefined;
    attributes?: string | undefined;
    tags?: string | undefined;

    constructor(data?: ISettingOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.key = _data["key"];
            this.type = _data["type"];
            this.value = _data["value"];
            this.attributes = _data["attributes"];
            this.tags = _data["tags"];
        }
    }

    static fromJS(data: any): SettingOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["key"] = this.key;
        data["type"] = this.type;
        data["value"] = this.value;
        data["attributes"] = this.attributes;
        data["tags"] = this.tags;
        return data;
    }
}

export interface ISettingOutputDto {
    id?: string | undefined;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    tenantId?: number | undefined;
    userId?: string | undefined;
    key?: string | undefined;
    type?: string | undefined;
    value?: string | undefined;
    attributes?: string | undefined;
    tags?: string | undefined;
}

export class SignOutDto implements ISignOutDto {
    connectionId?: string | undefined;
    clientAccessToken?: string | undefined;

    constructor(data?: ISignOutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.connectionId = _data["connectionId"];
            this.clientAccessToken = _data["clientAccessToken"];
        }
    }

    static fromJS(data: any): SignOutDto {
        data = typeof data === 'object' ? data : {};
        let result = new SignOutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionId"] = this.connectionId;
        data["clientAccessToken"] = this.clientAccessToken;
        return data;
    }
}

export interface ISignOutDto {
    connectionId?: string | undefined;
    clientAccessToken?: string | undefined;
}

export class StringEntityDto implements IStringEntityDto {
    id?: string | undefined;

    constructor(data?: IStringEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StringEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new StringEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IStringEntityDto {
    id?: string | undefined;
}

export class TenantDto implements ITenantDto {
    id?: number;
    name!: string;
    tenancyName!: string;
    connectionString?: string | undefined;
    isActive?: boolean;
    domain?: string | undefined;
    entityId?: string | undefined;
    types?: string | undefined;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.tenancyName = _data["tenancyName"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
            this.domain = _data["domain"];
            this.entityId = _data["entityId"];
            this.types = _data["types"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["tenancyName"] = this.tenancyName;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["domain"] = this.domain;
        data["entityId"] = this.entityId;
        data["types"] = this.types;
        return data;
    }
}

export interface ITenantDto {
    id?: number;
    name: string;
    tenancyName: string;
    connectionString?: string | undefined;
    isActive?: boolean;
    domain?: string | undefined;
    entityId?: string | undefined;
    types?: string | undefined;
}

export class TenantInputDto implements ITenantInputDto {
    id?: number;
    name!: string;
    tenancyName!: string;
    connectionString?: string | undefined;
    isActive?: boolean;
    domain?: string | undefined;
    entityId?: string | undefined;
    types?: string | undefined;
    userId?: string | undefined;
    emailAddress?: string | undefined;
    password?: string | undefined;

    constructor(data?: ITenantInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.tenancyName = _data["tenancyName"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
            this.domain = _data["domain"];
            this.entityId = _data["entityId"];
            this.types = _data["types"];
            this.userId = _data["userId"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): TenantInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["tenancyName"] = this.tenancyName;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["domain"] = this.domain;
        data["entityId"] = this.entityId;
        data["types"] = this.types;
        data["userId"] = this.userId;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        return data;
    }
}

export interface ITenantInputDto {
    id?: number;
    name: string;
    tenancyName: string;
    connectionString?: string | undefined;
    isActive?: boolean;
    domain?: string | undefined;
    entityId?: string | undefined;
    types?: string | undefined;
    userId?: string | undefined;
    emailAddress?: string | undefined;
    password?: string | undefined;
}

export class TenantModel implements ITenantModel {
    id!: number;
    name!: string;

    constructor(data?: ITenantModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TenantModel {
        data = typeof data === 'object' ? data : {};
        let result = new TenantModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ITenantModel {
    id: number;
    name: string;
}

export class TenantOutputDto implements ITenantOutputDto {
    id?: number;
    name!: string;
    tenancyName!: string;
    connectionString?: string | undefined;
    isActive?: boolean;
    domain?: string | undefined;
    entityId?: string | undefined;
    types?: string | undefined;
    userId?: string | undefined;
    emailAddress?: string | undefined;

    constructor(data?: ITenantOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.tenancyName = _data["tenancyName"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
            this.domain = _data["domain"];
            this.entityId = _data["entityId"];
            this.types = _data["types"];
            this.userId = _data["userId"];
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): TenantOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["tenancyName"] = this.tenancyName;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["domain"] = this.domain;
        data["entityId"] = this.entityId;
        data["types"] = this.types;
        data["userId"] = this.userId;
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface ITenantOutputDto {
    id?: number;
    name: string;
    tenancyName: string;
    connectionString?: string | undefined;
    isActive?: boolean;
    domain?: string | undefined;
    entityId?: string | undefined;
    types?: string | undefined;
    userId?: string | undefined;
    emailAddress?: string | undefined;
}

export class TenantSettingInputDto implements ITenantSettingInputDto {
    tenantId?: number | undefined;
    userId?: string | undefined;
    key?: string | undefined;
    inputValue?: string | undefined;
    outputValue?: string | undefined;

    constructor(data?: ITenantSettingInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.key = _data["key"];
            this.inputValue = _data["inputValue"];
            this.outputValue = _data["outputValue"];
        }
    }

    static fromJS(data: any): TenantSettingInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["key"] = this.key;
        data["inputValue"] = this.inputValue;
        data["outputValue"] = this.outputValue;
        return data;
    }
}

export interface ITenantSettingInputDto {
    tenantId?: number | undefined;
    userId?: string | undefined;
    key?: string | undefined;
    inputValue?: string | undefined;
    outputValue?: string | undefined;
}

export class UserDto implements IUserDto {
    id?: string | undefined;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    emailAddress?: string | undefined;
    fullName?: string | undefined;
    isActive?: boolean;
    isEmailConfirmed?: boolean;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    dob?: string | undefined;
    attributes?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.fullName = _data["fullName"];
            this.isActive = _data["isActive"];
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            this.phoneNumber = _data["phoneNumber"];
            this.gender = _data["gender"];
            this.dob = _data["dob"];
            this.attributes = _data["attributes"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["fullName"] = this.fullName;
        data["isActive"] = this.isActive;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["phoneNumber"] = this.phoneNumber;
        data["gender"] = this.gender;
        data["dob"] = this.dob;
        data["attributes"] = this.attributes;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        return data;
    }
}

export interface IUserDto {
    id?: string | undefined;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    emailAddress?: string | undefined;
    fullName?: string | undefined;
    isActive?: boolean;
    isEmailConfirmed?: boolean;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    dob?: string | undefined;
    attributes?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
}

export class UserInputDto implements IUserInputDto {
    id?: string | undefined;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    emailAddress?: string | undefined;
    fullName?: string | undefined;
    profiles?: string | undefined;
    contacts?: string | undefined;
    isActive?: boolean;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    dob?: string | undefined;
    attributes?: string | undefined;

    constructor(data?: IUserInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.fullName = _data["fullName"];
            this.profiles = _data["profiles"];
            this.contacts = _data["contacts"];
            this.isActive = _data["isActive"];
            this.phoneNumber = _data["phoneNumber"];
            this.gender = _data["gender"];
            this.dob = _data["dob"];
            this.attributes = _data["attributes"];
        }
    }

    static fromJS(data: any): UserInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["fullName"] = this.fullName;
        data["profiles"] = this.profiles;
        data["contacts"] = this.contacts;
        data["isActive"] = this.isActive;
        data["phoneNumber"] = this.phoneNumber;
        data["gender"] = this.gender;
        data["dob"] = this.dob;
        data["attributes"] = this.attributes;
        return data;
    }
}

export interface IUserInputDto {
    id?: string | undefined;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    emailAddress?: string | undefined;
    fullName?: string | undefined;
    profiles?: string | undefined;
    contacts?: string | undefined;
    isActive?: boolean;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    dob?: string | undefined;
    attributes?: string | undefined;
}

export class UserJobSettingInputDto implements IUserJobSettingInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    listTitle?: string | undefined;
    listIndustry?: string | undefined;
    jobLevel?: string | undefined;
    workingType?: string | undefined;
    experience?: string | undefined;
    position?: string | undefined;
    age?: string | undefined;
    gender?: string | undefined;
    workingHours?: string | undefined;
    listLocation?: string | undefined;
    canChangeWorkplace?: boolean;
    salaryMin?: number;
    salaryMax?: number;
    currency?: string | undefined;
    salaryNote?: string | undefined;
    isLookingForJob?: boolean;
    isSearchByEmployerAllowed?: boolean;
    receiveSuggestions?: boolean;
    allowContact?: boolean;
    showEmail?: boolean;
    showPhone?: boolean;
    contactEmail?: string | undefined;
    contactPhone?: string | undefined;
    applyLink?: string | undefined;

    constructor(data?: IUserJobSettingInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this._Name = _data["_Name"];
            this.listTitle = _data["listTitle"];
            this.listIndustry = _data["listIndustry"];
            this.jobLevel = _data["jobLevel"];
            this.workingType = _data["workingType"];
            this.experience = _data["experience"];
            this.position = _data["position"];
            this.age = _data["age"];
            this.gender = _data["gender"];
            this.workingHours = _data["workingHours"];
            this.listLocation = _data["listLocation"];
            this.canChangeWorkplace = _data["canChangeWorkplace"];
            this.salaryMin = _data["salaryMin"];
            this.salaryMax = _data["salaryMax"];
            this.currency = _data["currency"];
            this.salaryNote = _data["salaryNote"];
            this.isLookingForJob = _data["isLookingForJob"];
            this.isSearchByEmployerAllowed = _data["isSearchByEmployerAllowed"];
            this.receiveSuggestions = _data["receiveSuggestions"];
            this.allowContact = _data["allowContact"];
            this.showEmail = _data["showEmail"];
            this.showPhone = _data["showPhone"];
            this.contactEmail = _data["contactEmail"];
            this.contactPhone = _data["contactPhone"];
            this.applyLink = _data["applyLink"];
        }
    }

    static fromJS(data: any): UserJobSettingInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserJobSettingInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["_Name"] = this._Name;
        data["listTitle"] = this.listTitle;
        data["listIndustry"] = this.listIndustry;
        data["jobLevel"] = this.jobLevel;
        data["workingType"] = this.workingType;
        data["experience"] = this.experience;
        data["position"] = this.position;
        data["age"] = this.age;
        data["gender"] = this.gender;
        data["workingHours"] = this.workingHours;
        data["listLocation"] = this.listLocation;
        data["canChangeWorkplace"] = this.canChangeWorkplace;
        data["salaryMin"] = this.salaryMin;
        data["salaryMax"] = this.salaryMax;
        data["currency"] = this.currency;
        data["salaryNote"] = this.salaryNote;
        data["isLookingForJob"] = this.isLookingForJob;
        data["isSearchByEmployerAllowed"] = this.isSearchByEmployerAllowed;
        data["receiveSuggestions"] = this.receiveSuggestions;
        data["allowContact"] = this.allowContact;
        data["showEmail"] = this.showEmail;
        data["showPhone"] = this.showPhone;
        data["contactEmail"] = this.contactEmail;
        data["contactPhone"] = this.contactPhone;
        data["applyLink"] = this.applyLink;
        return data;
    }
}

export interface IUserJobSettingInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    listTitle?: string | undefined;
    listIndustry?: string | undefined;
    jobLevel?: string | undefined;
    workingType?: string | undefined;
    experience?: string | undefined;
    position?: string | undefined;
    age?: string | undefined;
    gender?: string | undefined;
    workingHours?: string | undefined;
    listLocation?: string | undefined;
    canChangeWorkplace?: boolean;
    salaryMin?: number;
    salaryMax?: number;
    currency?: string | undefined;
    salaryNote?: string | undefined;
    isLookingForJob?: boolean;
    isSearchByEmployerAllowed?: boolean;
    receiveSuggestions?: boolean;
    allowContact?: boolean;
    showEmail?: boolean;
    showPhone?: boolean;
    contactEmail?: string | undefined;
    contactPhone?: string | undefined;
    applyLink?: string | undefined;
}

export class UserJobSettingOutputDto implements IUserJobSettingOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    listTitle?: string | undefined;
    listIndustry?: string | undefined;
    jobLevel?: string | undefined;
    workingType?: string | undefined;
    experience?: string | undefined;
    position?: string | undefined;
    age?: string | undefined;
    gender?: string | undefined;
    workingHours?: string | undefined;
    listLocation?: string | undefined;
    canChangeWorkplace?: boolean;
    salaryMin?: number;
    salaryMax?: number;
    currency?: string | undefined;
    salaryNote?: string | undefined;
    isLookingForJob?: boolean;
    isSearchByEmployerAllowed?: boolean;
    receiveSuggestions?: boolean;
    allowContact?: boolean;
    showEmail?: boolean;
    showPhone?: boolean;
    contactEmail?: string | undefined;
    contactPhone?: string | undefined;
    applyLink?: string | undefined;

    constructor(data?: IUserJobSettingOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this._Name = _data["_Name"];
            this.listTitle = _data["listTitle"];
            this.listIndustry = _data["listIndustry"];
            this.jobLevel = _data["jobLevel"];
            this.workingType = _data["workingType"];
            this.experience = _data["experience"];
            this.position = _data["position"];
            this.age = _data["age"];
            this.gender = _data["gender"];
            this.workingHours = _data["workingHours"];
            this.listLocation = _data["listLocation"];
            this.canChangeWorkplace = _data["canChangeWorkplace"];
            this.salaryMin = _data["salaryMin"];
            this.salaryMax = _data["salaryMax"];
            this.currency = _data["currency"];
            this.salaryNote = _data["salaryNote"];
            this.isLookingForJob = _data["isLookingForJob"];
            this.isSearchByEmployerAllowed = _data["isSearchByEmployerAllowed"];
            this.receiveSuggestions = _data["receiveSuggestions"];
            this.allowContact = _data["allowContact"];
            this.showEmail = _data["showEmail"];
            this.showPhone = _data["showPhone"];
            this.contactEmail = _data["contactEmail"];
            this.contactPhone = _data["contactPhone"];
            this.applyLink = _data["applyLink"];
        }
    }

    static fromJS(data: any): UserJobSettingOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserJobSettingOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["_Name"] = this._Name;
        data["listTitle"] = this.listTitle;
        data["listIndustry"] = this.listIndustry;
        data["jobLevel"] = this.jobLevel;
        data["workingType"] = this.workingType;
        data["experience"] = this.experience;
        data["position"] = this.position;
        data["age"] = this.age;
        data["gender"] = this.gender;
        data["workingHours"] = this.workingHours;
        data["listLocation"] = this.listLocation;
        data["canChangeWorkplace"] = this.canChangeWorkplace;
        data["salaryMin"] = this.salaryMin;
        data["salaryMax"] = this.salaryMax;
        data["currency"] = this.currency;
        data["salaryNote"] = this.salaryNote;
        data["isLookingForJob"] = this.isLookingForJob;
        data["isSearchByEmployerAllowed"] = this.isSearchByEmployerAllowed;
        data["receiveSuggestions"] = this.receiveSuggestions;
        data["allowContact"] = this.allowContact;
        data["showEmail"] = this.showEmail;
        data["showPhone"] = this.showPhone;
        data["contactEmail"] = this.contactEmail;
        data["contactPhone"] = this.contactPhone;
        data["applyLink"] = this.applyLink;
        return data;
    }
}

export interface IUserJobSettingOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    listTitle?: string | undefined;
    listIndustry?: string | undefined;
    jobLevel?: string | undefined;
    workingType?: string | undefined;
    experience?: string | undefined;
    position?: string | undefined;
    age?: string | undefined;
    gender?: string | undefined;
    workingHours?: string | undefined;
    listLocation?: string | undefined;
    canChangeWorkplace?: boolean;
    salaryMin?: number;
    salaryMax?: number;
    currency?: string | undefined;
    salaryNote?: string | undefined;
    isLookingForJob?: boolean;
    isSearchByEmployerAllowed?: boolean;
    receiveSuggestions?: boolean;
    allowContact?: boolean;
    showEmail?: boolean;
    showPhone?: boolean;
    contactEmail?: string | undefined;
    contactPhone?: string | undefined;
    applyLink?: string | undefined;
}

export class UserJobSettingOutputDtoPagedResultDto implements IUserJobSettingOutputDtoPagedResultDto {
    items?: UserJobSettingOutputDto[] | undefined;
    totalCount?: number;

    constructor(data?: IUserJobSettingOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserJobSettingOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): UserJobSettingOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserJobSettingOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IUserJobSettingOutputDtoPagedResultDto {
    items?: UserJobSettingOutputDto[] | undefined;
    totalCount?: number;
}

export class UserJobSettingQueryDto implements IUserJobSettingQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: IUserJobSettingQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UserJobSettingQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserJobSettingQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUserJobSettingQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class UserOrganizationDto implements IUserOrganizationDto {
    organization?: OrganizationOutputDto;
    role?: RoleOutputDto;

    constructor(data?: IUserOrganizationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organization = _data["organization"] ? OrganizationOutputDto.fromJS(_data["organization"]) : undefined as any;
            this.role = _data["role"] ? RoleOutputDto.fromJS(_data["role"]) : undefined as any;
        }
    }

    static fromJS(data: any): UserOrganizationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserOrganizationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organization"] = this.organization ? this.organization.toJSON() : undefined as any;
        data["role"] = this.role ? this.role.toJSON() : undefined as any;
        return data;
    }
}

export interface IUserOrganizationDto {
    organization?: OrganizationOutputDto;
    role?: RoleOutputDto;
}

export class UserOrganizationsDto implements IUserOrganizationsDto {
    organizationId?: string | undefined;
    roleId?: string | undefined;

    constructor(data?: IUserOrganizationsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationId = _data["organizationId"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): UserOrganizationsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserOrganizationsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationId"] = this.organizationId;
        data["roleId"] = this.roleId;
        return data;
    }
}

export interface IUserOrganizationsDto {
    organizationId?: string | undefined;
    roleId?: string | undefined;
}

export class UserOutputDto implements IUserOutputDto {
    id?: string | undefined;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    emailAddress?: string | undefined;
    fullName?: string | undefined;
    profiles?: string | undefined;
    contacts?: string | undefined;
    isActive?: boolean;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    dob?: string | undefined;
    attributes?: string | undefined;
    organizations?: OrganizationOutputDto[] | undefined;

    constructor(data?: IUserOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.fullName = _data["fullName"];
            this.profiles = _data["profiles"];
            this.contacts = _data["contacts"];
            this.isActive = _data["isActive"];
            this.phoneNumber = _data["phoneNumber"];
            this.gender = _data["gender"];
            this.dob = _data["dob"];
            this.attributes = _data["attributes"];
            if (Array.isArray(_data["organizations"])) {
                this.organizations = [] as any;
                for (let item of _data["organizations"])
                    this.organizations!.push(OrganizationOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["fullName"] = this.fullName;
        data["profiles"] = this.profiles;
        data["contacts"] = this.contacts;
        data["isActive"] = this.isActive;
        data["phoneNumber"] = this.phoneNumber;
        data["gender"] = this.gender;
        data["dob"] = this.dob;
        data["attributes"] = this.attributes;
        if (Array.isArray(this.organizations)) {
            data["organizations"] = [];
            for (let item of this.organizations)
                data["organizations"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IUserOutputDto {
    id?: string | undefined;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    emailAddress?: string | undefined;
    fullName?: string | undefined;
    profiles?: string | undefined;
    contacts?: string | undefined;
    isActive?: boolean;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    dob?: string | undefined;
    attributes?: string | undefined;
    organizations?: OrganizationOutputDto[] | undefined;
}

export class UserOutputDtoPagedResultDto implements IUserOutputDtoPagedResultDto {
    items?: UserOutputDto[] | undefined;
    totalCount?: number;

    constructor(data?: IUserOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): UserOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IUserOutputDtoPagedResultDto {
    items?: UserOutputDto[] | undefined;
    totalCount?: number;
}

export class UserProfileInputDto implements IUserProfileInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    userId?: string | undefined;
    customerId?: string | undefined;
    surname?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    dob?: string | undefined;
    location?: string | undefined;
    headline?: string | undefined;
    about?: string | undefined;
    profilePicture?: string | undefined;
    bannerImage?: string | undefined;
    summary?: string | undefined;
    listValueJobField?: string | undefined;
    description?: string | undefined;
    note?: string | undefined;

    constructor(data?: IUserProfileInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this._Name = _data["_Name"];
            this.userId = _data["userId"];
            this.customerId = _data["customerId"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.gender = _data["gender"];
            this.dob = _data["dob"];
            this.location = _data["location"];
            this.headline = _data["headline"];
            this.about = _data["about"];
            this.profilePicture = _data["profilePicture"];
            this.bannerImage = _data["bannerImage"];
            this.summary = _data["summary"];
            this.listValueJobField = _data["listValueJobField"];
            this.description = _data["description"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): UserProfileInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfileInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["_Name"] = this._Name;
        data["userId"] = this.userId;
        data["customerId"] = this.customerId;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["gender"] = this.gender;
        data["dob"] = this.dob;
        data["location"] = this.location;
        data["headline"] = this.headline;
        data["about"] = this.about;
        data["profilePicture"] = this.profilePicture;
        data["bannerImage"] = this.bannerImage;
        data["summary"] = this.summary;
        data["listValueJobField"] = this.listValueJobField;
        data["description"] = this.description;
        data["note"] = this.note;
        return data;
    }
}

export interface IUserProfileInputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    userId?: string | undefined;
    customerId?: string | undefined;
    surname?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    dob?: string | undefined;
    location?: string | undefined;
    headline?: string | undefined;
    about?: string | undefined;
    profilePicture?: string | undefined;
    bannerImage?: string | undefined;
    summary?: string | undefined;
    listValueJobField?: string | undefined;
    description?: string | undefined;
    note?: string | undefined;
}

export class UserProfileOutputDto implements IUserProfileOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    userId?: string | undefined;
    customerId?: string | undefined;
    surname?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    dob?: string | undefined;
    location?: string | undefined;
    headline?: string | undefined;
    about?: string | undefined;
    profilePicture?: string | undefined;
    bannerImage?: string | undefined;
    summary?: string | undefined;
    listValueJobField?: string | undefined;
    description?: string | undefined;
    note?: string | undefined;
    numberInterest?: number;

    constructor(data?: IUserProfileOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this._Name = _data["_Name"];
            this.userId = _data["userId"];
            this.customerId = _data["customerId"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.gender = _data["gender"];
            this.dob = _data["dob"];
            this.location = _data["location"];
            this.headline = _data["headline"];
            this.about = _data["about"];
            this.profilePicture = _data["profilePicture"];
            this.bannerImage = _data["bannerImage"];
            this.summary = _data["summary"];
            this.listValueJobField = _data["listValueJobField"];
            this.description = _data["description"];
            this.note = _data["note"];
            this.numberInterest = _data["numberInterest"];
        }
    }

    static fromJS(data: any): UserProfileOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfileOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["_Name"] = this._Name;
        data["userId"] = this.userId;
        data["customerId"] = this.customerId;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["gender"] = this.gender;
        data["dob"] = this.dob;
        data["location"] = this.location;
        data["headline"] = this.headline;
        data["about"] = this.about;
        data["profilePicture"] = this.profilePicture;
        data["bannerImage"] = this.bannerImage;
        data["summary"] = this.summary;
        data["listValueJobField"] = this.listValueJobField;
        data["description"] = this.description;
        data["note"] = this.note;
        data["numberInterest"] = this.numberInterest;
        return data;
    }
}

export interface IUserProfileOutputDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    _Name?: string | undefined;
    userId?: string | undefined;
    customerId?: string | undefined;
    surname?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    dob?: string | undefined;
    location?: string | undefined;
    headline?: string | undefined;
    about?: string | undefined;
    profilePicture?: string | undefined;
    bannerImage?: string | undefined;
    summary?: string | undefined;
    listValueJobField?: string | undefined;
    description?: string | undefined;
    note?: string | undefined;
    numberInterest?: number;
}

export class UserProfileOutputDtoPagedResultDto implements IUserProfileOutputDtoPagedResultDto {
    items?: UserProfileOutputDto[] | undefined;
    totalCount?: number;

    constructor(data?: IUserProfileOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserProfileOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): UserProfileOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfileOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IUserProfileOutputDtoPagedResultDto {
    items?: UserProfileOutputDto[] | undefined;
    totalCount?: number;
}

export class UserProfileQueryDto implements IUserProfileQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: IUserProfileQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UserProfileQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfileQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUserProfileQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class UserQueryDto implements IUserQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;

    constructor(data?: IUserQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            if (Array.isArray(_data["criterias"])) {
                this.criterias = [] as any;
                for (let item of _data["criterias"])
                    this.criterias!.push(ICriteriaRequestDto.fromJS(item));
            }
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.language = _data["language"];
            this.code = _data["code"];
            this.option = _data["option"];
            this.search = _data["search"];
            this.status = _data["status"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(QueryKeyValueDto.fromJS(item));
            }
            this.cacheKey = _data["cacheKey"];
        }
    }

    static fromJS(data: any): UserQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (Array.isArray(this.criterias)) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item ? item.toJSON() : undefined as any);
        }
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["language"] = this.language;
        data["code"] = this.code;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["cacheKey"] = this.cacheKey;
        return data;
    }
}

export interface IUserQueryDto {
    maxResultCount?: number;
    skipCount?: number;
    sorting?: string | undefined;
    criterias?: ICriteriaRequestDto[] | undefined;
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    tenantId?: number | undefined;
    userId?: string | undefined;
    language?: string | undefined;
    code?: string | undefined;
    option?: string | undefined;
    search?: string | undefined;
    status?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    keyValues?: QueryKeyValueDto[] | undefined;
    cacheKey?: string | undefined;
}

export class ValueDto implements IValueDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    data?: string | undefined;

    constructor(data?: IValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.keyData = _data["keyData"];
            this.tags = _data["tags"];
            this.clientFiles = _data["clientFiles"];
            this.files = _data["files"];
            this.attributes = _data["attributes"];
            this.extension = _data["extension"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : undefined as any;
            this.creationDateTime = _data["creationDateTime"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(IReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["keyValues"])) {
                this.keyValues = [] as any;
                for (let item of _data["keyValues"])
                    this.keyValues!.push(IKeyValueDto.fromJS(item));
            }
            if (Array.isArray(_data["languageValues"])) {
                this.languageValues = [] as any;
                for (let item of _data["languageValues"])
                    this.languageValues!.push(ILanguageValueDto.fromJS(item));
            }
            this.option = _data["option"];
            this.extValue = _data["extValue"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : undefined as any;
            this.lastModificationDateTime = _data["lastModificationDateTime"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): ValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["keyData"] = this.keyData;
        data["tags"] = this.tags;
        data["clientFiles"] = this.clientFiles;
        data["files"] = this.files;
        data["attributes"] = this.attributes;
        data["extension"] = this.extension;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : undefined as any;
        data["creationDateTime"] = this.creationDateTime;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.keyValues)) {
            data["keyValues"] = [];
            for (let item of this.keyValues)
                data["keyValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.languageValues)) {
            data["languageValues"] = [];
            for (let item of this.languageValues)
                data["languageValues"].push(item ? item.toJSON() : undefined as any);
        }
        data["option"] = this.option;
        data["extValue"] = this.extValue;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : undefined as any;
        data["lastModificationDateTime"] = this.lastModificationDateTime;
        data["data"] = this.data;
        return data;
    }
}

export interface IValueDto {
    id?: string | undefined;
    tenantId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    status?: string | undefined;
    statusName?: string | undefined;
    keyData?: string | undefined;
    tags?: string | undefined;
    clientFiles?: string | undefined;
    files?: string | undefined;
    attributes?: string | undefined;
    extension?: string | undefined;
    creatorUserId?: string | undefined;
    creationTime?: Date;
    creationDateTime?: number;
    references?: IReferenceDto[] | undefined;
    keyValues?: IKeyValueDto[] | undefined;
    languageValues?: ILanguageValueDto[] | undefined;
    option?: string | undefined;
    extValue?: string | undefined;
    lastModifierUserId?: string | undefined;
    lastModificationTime?: Date;
    lastModificationDateTime?: number;
    data?: string | undefined;
}

export class ViewDto implements IViewDto {
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    option?: string | undefined;

    constructor(data?: IViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.view = _data["view"];
            this.useCache = _data["useCache"];
            this.option = _data["option"];
        }
    }

    static fromJS(data: any): ViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new ViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["view"] = this.view;
        data["useCache"] = this.useCache;
        data["option"] = this.option;
        return data;
    }
}

export interface IViewDto {
    id?: string | undefined;
    view?: string | undefined;
    useCache?: boolean;
    option?: string | undefined;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}